/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as moment from "moment";

export interface GetInAppUpdateTokenResponse {
  /**
   * The api token generated will not be accessible again
  */
  token: string;
}

export interface ApiTokensCreateResponse {
  /**
   * The unique id (UUID) of the api token
  */
  id: string;
  /**
   * The api token generated will not be accessible again
  */
  apiToken: string;
  /**
   * The description of the token
  */
  description?: string;
  /**
   * The scope for this token.
  */
  scope?: string[];
  /**
   * The creation time
  */
  createdAt: string;
}

export interface ApiTokensCreateRequest {
  /**
   * The description of the token
  */
  description?: string;
  /**
   * The scope for this token.
  */
  scope?: string[];
}

export interface ApiTokensGetResponse {
  /**
   * The unique id (UUID) of the api token
  */
  id: string;
  /**
   * The description of the token
  */
  description?: string;
  /**
   * The scope for this token.
  */
  scope?: string[];
  /**
   * The creation time
  */
  createdAt: string;
}

export interface Status {
  status: string;
}

export interface Failure {
  message: string;
}

export interface ErrorDetails {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ErrorResponse {
  error: ErrorDetails;
}

export interface SuccessResponse {
  message: string;
}

export interface AADTenantAddRequest {
  /**
   * The user wanting to add this tenant to the organization, must be an admin of the organization
  */
  userId: string;
  /**
   * The AAD tenant id
  */
  aadTenantId: string;
  /**
   * The name of the AAD Tenant
  */
  displayName: string;
}

export interface AADTenantResponse {
  /**
   * The AAD tenant id
  */
  aadTenantId: string;
  /**
   * The name of the AAD Tenant
  */
  displayName: string;
}

export interface AddAppTesterRequest {
  /**
   * The user ID of the tester that needs to be added
  */
  userId: string;
  /**
   * The ID of the release the user was added to
  */
  releaseId: number;
}

export interface AddAppTesterResponse {
  /**
   * The user ID of the tester that needs to be added
  */
  userId: string;
  /**
   * The ID of the release the user was added to
  */
  releaseId: number;
}

export interface ApiTokensPostRequest {
  /**
   * The description of the token
  */
  description?: string;
  /**
   * An encrypted value of the token.
  */
  encryptedToken?: string;
  /**
   * The scope for this token. An array of supported roles.
  */
  scope?: string[];
  /**
   * The hashed value of api token
  */
  tokenHash?: string;
  /**
   * The token's type. public:managed by the user; in_app_update:special token for in-app update
   * scenario; buid:dedicated for CI usage for now; session:for CLI session management; tester_app:
   * used for tester mobile app; default is "public".'. Possible values include: 'public',
   * 'in_app_update', 'build', 'session', 'tester_app'
  */
  tokenType?: string;
}

export interface AppPatchRequest {
  /**
   * A short text describing the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName?: string;
  /**
   * A one-word descriptive release type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The name of the app used in URLs
  */
  name?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
}

export interface AppRepoPatchRequest {
  /**
   * The absolute URL of the repository
  */
  repoUrl?: string;
  /**
   * The unique id (UUID) of the user
  */
  userId?: string;
}

export interface AppRepoPostRequest {
  /**
   * The absolute URL of the repository
  */
  repoUrl: string;
  /**
   * The provider of the repository. Possible values include: 'github', 'bitbucket', 'vsts'
  */
  repoProvider?: string;
  /**
   * The unique id (UUID) of the user who configured the repository
  */
  userId: string;
  /**
   * Installation id from the provider
  */
  installationId?: string;
  /**
   * Repository id from the provider
  */
  repoId?: string;
}

export interface AppRequest {
  /**
   * A short text describing the app
  */
  description?: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The descriptive name of the app. This can contain any characters
  */
  displayName: string;
  /**
   * The name of the app used in URLs
  */
  name?: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux'
  */
  os: string;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Xamarin', 'Unity', 'Electron'
  */
  platform: string;
}

export interface AppAddRequest {
  /**
   * The name of the app to be added to the distribution group
  */
  name: string;
}

export interface AppDeleteRequest {
  /**
   * The name of the app to be deleted from the distribution group
  */
  name: string;
}

export interface AzureSubscriptionAddRequest {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
}

export interface AzureSubscriptionUpdateBillableRequest {
  /**
   * Billable status of the subscription
  */
  isBillable: boolean;
}

export interface AzureSubscriptionPatchRequest {
  /**
   * If the subscription is used for billing
  */
  isBilling: boolean;
}

export interface AzureSubscriptionAddToAppRequest {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
}

export interface DistributionGroupPatchRequest {
  /**
   * The name of the distribution group
  */
  name?: string;
  /**
   * Whether the distribution group is public
  */
  isPublic?: boolean;
}

export interface DistributionGroupRequest {
  /**
   * The name of the distribution group
  */
  name: string;
  /**
   * The display name of the distribution group. If not specified, the name will be used.
  */
  displayName?: string;
}

export interface AppDistributionGroupUsersRequest {
  memberIds?: string[];
}

export interface DistributionGroupUserRequest {
  /**
   * The list of emails of the users
  */
  userEmails?: string[];
}

export interface DistributionGroupAppAddRequest {
  /**
   * The list of apps to add to distribution group
  */
  apps?: AppAddRequest[];
}

export interface DistributionGroupAppsDeleteRequest {
  /**
   * The list of apps to delete from the distribution group
  */
  apps?: AppDeleteRequest[];
}

export interface DistributionGroupAADGroupsDeleteRequest {
  /**
   * The list of aad group ids
  */
  aadGroupIds?: string[];
}

export interface DataDeletionRequest {
  /**
   * Type of data to delete
  */
  dataDeletionType?: string;
}

export interface DistributionGroupAADGroupBase {
  /**
   * The id of the aad group
  */
  aadGroupId?: string;
  /**
   * The display name of the aad group
  */
  displayName?: string;
}

export interface DistributionGroupAADGroupRequest {
  /**
   * The list of aad group ids and names to add
  */
  aadGroups?: DistributionGroupAADGroupBase[];
}

export interface DistributionGroupIdRequest {
  /**
   * The id of the distribution group
  */
  id: string;
}

export interface DistributionGroupsUserVerifyRequest {
  /**
   * An array of distribution group ids
  */
  distributionGroupIds: DistributionGroupIdRequest[];
}

export interface EmailVerificationRequest {
  /**
   * The verification token that was sent to the user
  */
  token: string;
}

export interface ExternalUserRequest {
  /**
   * The token of the app invitation which lead to signup
  */
  appInvitation?: string;
  /**
   * The token of the test invitation which lead to signup
  */
  testerInvitation?: string;
  /**
   * The token of the organization invitation which lead to signup
  */
  organizationInvitation?: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user. If no explicit value is given, a default
   * will be auto-generated from the `display_name` value
  */
  name?: string;
}

export interface ExternalAppId {
  /**
   * The identifier for external apps that map to an App Center app
  */
  externalId?: string;
}

export interface FeaturePatchRequest {
  /**
   * The friendly name of the feature
  */
  description?: string;
  /**
   * The full (friendly) name of the feature.
  */
  displayName?: string;
  /**
   * The state of the feature
  */
  state?: number;
}

export interface FeatureCreateRequest {
  /**
   * The unique name of the feature
  */
  name: string;
  /**
   * The full (friendly) name of the feature.
  */
  displayName: string;
  /**
   * The state of the feature
  */
  state?: number;
  /**
   * The friendly name of the feature
  */
  description?: string;
}

export interface GrantAdminRoleRequest {
  /**
   * The new admin_role. Possible values include: 'superAdmin', 'admin', 'devOps',
   * 'customerSupport', 'notAdmin'
  */
  adminRole: string;
}

export interface InternalBulkAppResponse {
  /**
   * The name of the app
  */
  appName?: string;
  /**
   * The display name of the owner
  */
  ownerDisplayName?: string;
}

export interface InternalHockeyAppCompatibilityResponse {
  /**
   * The owner type of the app. Possible values include: 'user', 'organization'
  */
  ownerType?: string;
  /**
   * The OS of the app. Possible values include: 'Android', 'iOS', 'macOS', 'Windows', 'Linux',
   * 'Custom'
  */
  os?: string;
  /**
   * The OS of the app. Possible values include: 'Java', 'Objective-C-Swift', 'Cordova',
   * 'React-Native', 'Unity', 'Electron', 'Xamarin', 'Unknown'
  */
  platform?: string;
  /**
   * Does the HockeyApp app have crashes from within the last 90 days?
  */
  hasCrashes?: boolean;
  /**
   * Does the HockeyApp app have feedback from within the last 90 days?
  */
  hasFeedback?: boolean;
  /**
   * Does the HockeyApp app have metrics from within the last 30 days?
  */
  hasMetrics?: boolean;
  /**
   * Does the HockeyApp app have any external builds?
  */
  hasExternalBuilds?: boolean;
  /**
   * Does the HockeyApp app have any build server URLs specified?
  */
  hasSpecifiedBuildServerUrl?: boolean;
  /**
   * Does the HockeyApp app have an associated Distribution Group that is owned by a different
   * owner?
  */
  hasDistributionGroupsOutsideOfOwnership?: boolean;
  /**
   * Does the HockeyApp app's owner own any Distribution Groups?
  */
  ownerHasDistributionGroups?: boolean;
  /**
   * Does the HockeyApp app have any bugtracker configured? Which type?. Possible values include:
   * 'none', 'vso', 'jira5', 'github', 'other'
  */
  bugtrackerType?: string;
  /**
   * Does the HockeyApp app have any webhooks configured? Which types?
  */
  webhookTypes?: string[];
}

export interface InternalHockeyAppCutoverStatusResponse {
  /**
   * The ID of the app
  */
  id: string;
  /**
   * Does the HockeyApp app have crashes from within the last 90 days?. Possible values include:
   * 'not_requested', 'requested', 'in_progress', 'completed'
  */
  status?: string;
}

export interface InternalUserRequest {
  /**
   * The token of the app invitation which lead to signup
  */
  appInvitation?: string;
  /**
   * The token of the test invitation which lead to signup
  */
  testerInvitation?: string;
  /**
   * The token of the organization invitation which lead to signup
  */
  organizationInvitation?: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The password of the user. Needs to be at least 8 characters long and contain at least one
   * lower- and one uppercase letter.
  */
  password: string;
  /**
   * The sub-domain of the portal from which this request was made. Will be used to build the
   * invitation link. Possible values include: 'install.'
  */
  portalSubdomain?: string;
}

export interface OrganizationPatchRequest {
  /**
   * The full (friendly) name of the organization.
  */
  displayName?: string;
  /**
   * The name of the organization used in URLs
  */
  name?: string;
}

export interface OrganizationRequest {
  /**
   * The display name of the organization
  */
  displayName?: string;
  /**
   * The name of the organization used in URLs
  */
  name?: string;
}

export interface OrganizationUserPatchRequest {
  /**
   * The user's role in the organizatiion. Possible values include: 'admin', 'collaborator'
  */
  role?: string;
}

export interface AddOrganizationAdminRequest {
  /**
   * The internal unique id (UUID) of the account.
  */
  userId: string;
}

export interface TransferAppAdminRequest {
  /**
   * The internal unique id (UUID) of the user/org.
  */
  newOwnerId: string;
}

export interface PasswordUpdateRequest {
  /**
   * The new password that will be set for the user. Needs to be at least 8 characters long and
   * contain at least one lower- and one uppercase letter.
  */
  newPassword: string;
  /**
   * The old password, if needed.
  */
  oldPassword?: string;
}

export interface PostRepositoryProviderMappingRequest {
  /**
   * Id of user in the external provider service
  */
  externalAccountId: string;
  /**
   * App Center account id to link to this provider and external id
  */
  accountId: string;
}

export interface GetOrCreateRepositoryProviderMappingRequest {
  /**
   * The account name given by the external provider. If provided, create an organization and the
   * mapping. If not, create mapping with user.
  */
  externalAccountName?: string;
}

export interface ResendVerificationRequest {
  /**
   * The email or name of the user to resend verification
  */
  name: string;
}

export interface ResetPasswordUsingTokenRequest {
  /**
   * The new password. Needs to be at least 8 characters long and contain at least one lower- and
   * one uppercase letter.
  */
  newPassword: string;
  /**
   * The reset password token that was sent to the user
  */
  token: string;
}

export interface UserAppPermissionsUpdateRequest {
  /**
   * The permissions the user has for the app
  */
  permissions: string[];
}

export interface UserInvitationPermissionsUpdateRequest {
  /**
   * The permissions the user has for the app in the invitation
  */
  permissions: string[];
}

export interface UserEmailRequest {
  /**
   * The user's email address'
  */
  userEmail: string;
}

export interface UserNameUpdateRequest {
  /**
   * The new, unique name that is used to identify.
  */
  name?: string;
}

export interface UserUpdateRequest {
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
}

export interface UserUpdateRequestInternal {
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
  /**
   * The new, unique name that is used to identify.
  */
  name?: string;
  /**
   * The date in the future when the user should be checked again for NPS eligibility
  */
  nextNpsSurveyDate?: string;
  /**
   * The email address for this user
  */
  email?: string;
}

export interface UserSettingRequest {
  /**
   * The setting value
  */
  value: string;
}

export interface AccountResponse {
  /**
   * The internal unique id (UUID) of the account.
  */
  id: string;
  /**
   * The display name of the account
  */
  displayName: string;
  /**
   * The slug name of the account
  */
  name: string;
  /**
   * The account's email. For org that value might be empty.
  */
  email?: string;
  /**
   * The creation origin of this account. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The type of this account. Possible values include: 'user', 'org'
  */
  type: string;
}

export interface ApiTokenDeleteResponse {
  /**
   * The unique id (UUID) of the api token
  */
  id: string;
  /**
   * The hashed value of api token
  */
  tokenHash: string;
}

export interface ApiTokenGetUserResponse {
  /**
   * The token's unique id (UUID)
  */
  tokenId: string;
  /**
   * The token's scope. A list of allowed roles.
  */
  tokenScope: string[];
  /**
   * The user email
  */
  userEmail: string;
  /**
   * The unique id (UUID) of the user
  */
  userId: string;
  /**
   * The creation origin of the user who created this api token. Possible values include:
   * 'appcenter', 'hockeyapp', 'codepush'
  */
  userOrigin: string;
}

export interface ApiTokenResponse {
  /**
   * The unique id (UUID) of the api token
  */
  id: string;
  /**
   * The creation time
  */
  createdAt: string;
  /**
   * The token's scope. A list of allowed roles.
  */
  scope?: string[];
  /**
   * The encrypted value of a token. This value will only be returned for token of type
   * in_app_update.
  */
  encryptedToken?: string;
  /**
   * The description of the token
  */
  description?: string;
}

export interface AppGroupResponse {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The unique ID (UUID) of the group that the app belongs to
  */
  groupId: string;
  /**
   * The display name of the app
  */
  displayName?: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'Unknown'
  */
  platform: string;
}

export interface AzureSubscriptionResponse {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface BasicAppResponse {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  owner: Owner;
}

export interface AppResponse extends BasicAppResponse {
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: AzureSubscriptionResponse;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'Unknown'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

export interface UserProfileResponse {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The permissions the user has for the app
  */
  permissions?: string[];
  /**
   * The creation origin of this user. Possible values include: 'appcenter', 'hockeyapp',
   * 'codepush'
  */
  origin: string;
}

/**
 * The information about the app's owner
*/
export interface Owner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

/**
 * The organization that owns the distribution group, if it exists
*/
export interface AppInvitationDetailResponseDistributionGroup {
  owner?: Owner;
}

export interface AppInvitationDetailResponse {
  /**
   * The unique ID (UUID) of the invitation
  */
  id: string;
  app: AppResponse;
  /**
   * The email address of the invited user
  */
  email: string;
  /**
   * The invitation type. Possible values include: 'developer', 'tester'
  */
  inviteType: string;
  invitedBy: UserProfileResponse;
  /**
   * Indicates whether the invited user already exists
  */
  isExistingUser: boolean;
  /**
   * The permissions the user has for the app
  */
  permissions?: string[];
  /**
   * The number of apps in the group
  */
  appCount?: number;
  /**
   * The organization that owns the distribution group, if it exists
  */
  distributionGroup?: AppInvitationDetailResponseDistributionGroup;
}

export interface AppRepoResponse {
  /**
   * The unique id (UUID) of the repository integration
  */
  id: string;
  /**
   * The unique id (UUID) of the app that this repository integration belongs to
  */
  appId: string;
  /**
   * The absolute URL of the repository
  */
  repoUrl: string;
  /**
   * The provider of the repository. Possible values include: 'github', 'bitbucket', 'vsts'
  */
  repoProvider?: string;
  /**
   * The unique id (UUID) of the user who configured the repository
  */
  userId: string;
  /**
   * Installation id from the provider
  */
  installationId?: string;
  /**
   * Repository id from the provider
  */
  repoId?: string;
}

export interface TesterAppResponse extends BasicAppResponse {
  /**
   * it indicates if the app is microsoft internal
  */
  microsoftInternal?: boolean;
  /**
   * The permissions associated with the app
  */
  permissions?: string[];
}

export interface OrgDistributionGroupAppResponse extends BasicAppResponse {
  /**
   * The platform of the app
  */
  platform?: string;
  /**
   * The creation origin of this app
  */
  origin?: string;
}

export interface AppResponseInternalRepositoriesItem {
  repoProvider?: string;
  repoUrl?: string;
}

export interface AppResponseInternal extends AppResponse {
  /**
   * The feature flags that are enabled for this app
  */
  featureFlags?: string[];
  /**
   * The repositories associated with this app
  */
  repositories?: AppResponseInternalRepositoriesItem[];
}

export interface AppUserPermissionResponse {
  /**
   * The unique id (UUID) of the app
  */
  appId: string;
  /**
   * The permissions the user has for the app
  */
  permissions: string[];
  /**
   * The email of the user
  */
  userEmail: string;
  /**
   * The unique id (UUID) of the user
  */
  userId: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  appOrigin: string;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
}

export interface AppWithTeamPermissionsResponse extends AppResponse {
  /**
   * The permissions the team has for the app
  */
  teamPermissions?: string[];
}

export interface OrgUserPermissionResponse {
  /**
   * The unique id (UUID) of the org
  */
  orgId: string;
  /**
   * The user role for the org. Possible values include: 'admin', 'collaborator'
  */
  userRole: string;
}

export interface DistributionGroupResponse {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The name of the distribution group
  */
  displayName?: string;
  /**
   * The creation origin of this distribution group. Possible values include: 'appcenter',
   * 'hockeyapp'
  */
  origin: string;
  /**
   * Whether the distribution group is public
  */
  isPublic: boolean;
}

export interface DistributionGroupUserGetResponse {
  /**
   * The unique id (UUID) of the user
  */
  id?: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * Whether the has accepted the invite. Available when an invite is pending, and the value will
   * be "true".
  */
  invitePending?: boolean;
  /**
   * The unique name that is used to identify the user.
  */
  name?: string;
}

export interface DistributionGroupDetailsResponse extends DistributionGroupResponse {
  /**
   * Whether the distribution group is shared group or not
  */
  isShared: boolean;
  /**
   * The count of apps associated with this distribution group
  */
  totalAppsCount: number;
  /**
   * The count of users in the distribution group
  */
  totalUserCount: number;
  /**
   * The count of non-pending users in the distribution group who will be notified by new releases
  */
  notifiedUserCount: number;
  /**
   * Type of group (Default, HockeyAppDefault or MicrosoftDogfooding). Possible values include:
   * 'Default', 'HockeyAppDefault', 'MicrosoftDogfooding'
  */
  groupType?: string;
  /**
   * The distribution group users
  */
  users: DistributionGroupUserGetResponse[];
}

export interface OrgDistributionGroupDetailsResponse extends DistributionGroupResponse {
  /**
   * The count of apps associated with this distribution group
  */
  totalAppsCount: number;
  /**
   * The count of users in the distribution group
  */
  totalUsersCount: number;
  /**
   * The apps associated with the distribution group
  */
  apps: AppResponse[];
}

export interface GeneralDistributionGroupDetailsResponse extends DistributionGroupResponse {
  /**
   * Whether the distribution group is shared group or not
  */
  isShared: boolean;
  /**
   * If distribution group is owned by an app, this is the unique app ID
  */
  ownerAppId?: string;
  /**
   * If distribution group is owned by an org, this is the unique org ID
  */
  ownerOrgId?: string;
}

export interface DistributionGroupUserDeleteResponse {
  /**
   * The code of the result
  */
  code?: string;
  /**
   * The message of the result
  */
  message?: number;
  /**
   * The status code of the result
  */
  status: number;
  /**
   * The email of the user
  */
  userEmail?: string;
}

export interface OrganizationResponse {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
}

export interface CloseAccountOrganizationResponse extends OrganizationResponse {
  /**
   * The number of collaborators from the organization
  */
  collaboratorsCount: number;
}

export interface DistributionGroupUserPostResponse {
  /**
   * The code of the result
  */
  code?: string;
  /**
   * Whether the has accepted the invite. Available when an invite is pending, and the value will
   * be "true".
  */
  invitePending?: boolean;
  /**
   * The message of the result
  */
  message?: number;
  /**
   * The status code of the result
  */
  status: number;
  /**
   * The email of the user
  */
  userEmail?: string;
}

export interface DistributionGroupTesterGetResponse {
  /**
   * The full name of the tester. Might for example be first and last name
  */
  displayName?: string;
  /**
   * The unique name that is used to identify the tester.
  */
  name: string;
  /**
   * The email address of the tester
  */
  email: string;
}

export interface DistributionGroupAADGroupPostResponse {
  /**
   * The internal unique id (UUID) of the AAD group.
  */
  id?: string;
  /**
   * The AAD unique id (UUID) of the AAD group.
  */
  aadGroupId?: string;
  /**
   * The display name of the AAD group
  */
  displayName?: string;
}

export interface DistributionGroupAadGroupsDeleteResponse {
  /**
   * The code of the result
  */
  code?: string;
  /**
   * The message of the result
  */
  message?: number;
  /**
   * The status code of the result
  */
  status: number;
  /**
   * The aad id of the group
  */
  aadGroupId?: string;
}

export interface DistributionGroupWithUsersResponse {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The count of users in the distribution group
  */
  totalUserCount: number;
  /**
   * The count of aad groups in the distribution group
  */
  totalGroupsCount?: number;
  /**
   * The count of non-pending users in the distribution group who will be notified by new releases
  */
  notifiedUserCount: number;
  /**
   * Whether the distribution group is public
  */
  isPublic?: boolean;
  /**
   * The distribution group users
  */
  users: DistributionGroupUserGetResponse[];
  /**
   * The distribution group aad groups
  */
  aadGroups?: DistributionGroupAADGroupPostResponse[];
}

export interface FeatureFlagsResponse {
  featureFlags: string[];
}

export interface FeatureResponse {
  /**
   * The description of the feature
  */
  description?: string;
  /**
   * The friendly name of the feature
  */
  displayName: string;
  /**
   * The unique name of the feature
  */
  name: string;
  /**
   * The state (unset, enabled, disabled) of the feature
  */
  state: number;
}

export interface InternalUserSignupResponse {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The name of the external auth provider
  */
  externalProvider?: string;
  /**
   * The user ID given by the external provider
  */
  externalUserId?: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The current status of the user record after signup. Possible values include: 'Complete',
   * 'NeedsVerification'
  */
  status?: string;
}

export interface InvitationDetailResponse {
  /**
   * The id of the invitation
  */
  invitationId: string;
  invitedBy: UserProfileResponse;
  organization?: OrganizationResponse;
  app?: AppResponse;
}

export interface GDPRInvitationDetailResponse {
  /**
   * The id of the invitation
  */
  invitationId: string;
  organization?: OrganizationResponse;
  app?: AppResponse;
}

export interface OrgNameAvailabilityResponse {
  /**
   * The availability status of the requested org name
  */
  available: boolean;
  /**
   * The generated org name
  */
  name: string;
}

export interface OrganizationInvitationDetailResponse {
  /**
   * The unique ID (UUID) of the invitation
  */
  id: string;
  organization: OrganizationResponse;
  /**
   * The email address of the invited user
  */
  email: string;
  invitedBy: UserProfileResponse;
  /**
   * Indicates whether the invited user already exists
  */
  isExistingUser: boolean;
  /**
   * The role assigned to the invited user
  */
  role?: string;
}

export interface OrganizationInvitationSimpleDetailResponse {
  /**
   * The unique ID (UUID) of the invitation
  */
  id: string;
  /**
   * The email address of the invited user
  */
  email: string;
  /**
   * The role assigned to the invited user
  */
  role: string;
}

export interface OrganizationResponseInternal extends OrganizationResponse {
  /**
   * The feature flags that are enabled for this organization
  */
  featureFlags?: string[];
}

export interface OrganizationResponseManagement extends OrganizationResponseInternal {
  /**
   * The organization email, if the app was synced from HockeyApp
  */
  email?: string;
}

export interface OrganizationUserResponse {
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The date when the user joined the organization
  */
  joinedAt: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The role the user has within the organization
  */
  role: string;
}

export interface TeamAppUpdateRequest {
  /**
   * The permissions all members of the team have on the app
  */
  permissions: string[];
}

export interface TeamRequest {
  /**
   * The display name of the team
  */
  displayName: string;
  /**
   * The name of the team
  */
  name?: string;
  /**
   * The description of the team
  */
  description?: string;
}

export interface TeamResponse {
  /**
   * The internal unique id (UUID) of the team.
  */
  id: string;
  /**
   * The name of the team
  */
  name: string;
  /**
   * The display name of the team
  */
  displayName: string;
  /**
   * The description of the team
  */
  description?: string;
}

export interface TeamAppResponse extends TeamResponse {
  /**
   * The permissions the team has for the app
  */
  permissions?: string[];
}

export interface StatusResponse {
  status: string;
}

export interface PurgeResponse {
  status: string;
}

export interface SubscriptionMetrics {
  /**
   * The name of the subsciption (prefixed with the topic name)
  */
  name: string;
  /**
   * The number of messages in the subscription
  */
  messageCount: number;
}

export interface ServiceBusStatusResponse {
  status: string;
  subscriptions?: SubscriptionMetrics[];
}

export interface TeamUserResponse {
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The role of the user has within the team
  */
  role: any;
}

export interface UserAuthResponse {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The name of the external auth provider
  */
  externalProvider?: string;
  /**
   * The user ID given by the external provider
  */
  externalUserId?: string;
  /**
   * The unique name that is used to identify the user
  */
  name: string;
  /**
   * The creation origin of this user. Possible values include: 'appcenter', 'hockeyapp',
   * 'codepush'
  */
  origin: string;
}

export interface UserLiteProfileResponse {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
}

export interface UserNameAvailabilityResponse {
  /**
   * The availability status of the requested user name
  */
  available: boolean;
  /**
   * The requested user name
  */
  name: string;
}

export interface AppIntegration {
  /**
   * app id
  */
  appId: string;
  /**
   * integration state
  */
  state: string;
  /**
   * provider type
  */
  provider: string;
}

export interface AppIntegrationResponse {
  /**
   * app id
  */
  appId: string;
}

export interface AppMembershipsResponseMembershipsItem {
  appId?: string;
  userId?: string;
  permissions?: string[];
  /**
   * Possible values include: 'appcenter', 'hockeyapp', 'codepush', 'testcloud',
   * 'hockeyapp-dogfood'
  */
  origin?: string;
  /**
   * Possible values include: 'user', 'org', 'distribution_group', 'team', 'release'
  */
  sourceType?: string;
}

export interface AppMembershipsResponse {
  /**
   * The app's origin
  */
  appOrigin?: string;
  /**
   * An array of all ways a user has access to the app, based on the app_memberships table.
  */
  memberships?: AppMembershipsResponseMembershipsItem[];
}

/**
 * The user's settings
*/
export interface UserProfileResponseInternalSettings {
  /**
   * The marketing opt-in setting
  */
  marketingOptIn?: string;
}

export interface UserProfileResponseInternal extends UserProfileResponse {
  /**
   * The feature flags that are enabled for this app
  */
  featureFlags?: string[];
  /**
   * The new admin_role. Possible values include: 'superAdmin', 'admin', 'devOps',
   * 'customerSupport', 'notAdmin'
  */
  adminRole?: string;
  /**
   * The user's settings
  */
  settings?: UserProfileResponseInternalSettings;
}

export interface UserProfileResponseManagement extends UserProfileResponseInternal {
  /**
   * The date when the app was last updated
  */
  updatedAt?: string;
  /**
   * A boolean flag that indicates if the user is already verified
  */
  verified?: boolean;
}

/**
 * A user's setting
*/
export interface UserSettingResponse {
  /**
   * The marketing opt-in setting
  */
  marketingOptIn?: string;
}

/**
 * an AAD user's id and tenant id
*/
export interface AADUser {
  /**
   * the aad user's id
  */
  objectId: string;
  /**
   * the aad user's tenant id
  */
  tenantId: string;
}

/**
 * an MSA user's hex CID
*/
export interface MSAUser {
  /**
   * the user's CID
  */
  hexcid: string;
}

/**
 * Shared connection patch request
*/
export interface SharedConnectionPatchRequest {
  /**
   * Display name of the shared connection
  */
  displayName?: string;
  /**
   * Represents the data for connecting to service
  */
  data: any;
}

/**
 * SharedConnectionRequest
*/
export interface SharedConnectionRequest {
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * credential type of the shared connection. Values can be credentials|certificate. Possible
   * values include: 'credentials', 'certificate'
  */
  credentialType?: string;
  /**
   * Polymorphic Discriminator
  */
  serviceType: string;
}

/**
 * SharedConnectionResponse
*/
export interface SharedConnectionResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * the type of the credential. Possible values include: 'credentials', 'certificate'
  */
  credentialType: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * Polymorphic Discriminator
  */
  serviceType: string;
}

/**
 * PrivateSharedConnectionResponse
*/
export interface PrivateSharedConnectionResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * Polymorphic Discriminator
  */
  serviceType: string;
}

/**
 * Apple connection secrets
*/
export interface AppleConnectionSecretRequest extends SharedConnectionRequest {
}

/**
 * Apple secret details
*/
export interface AppleMultifactorSecretDetails {
  /**
   * username to connect to apple store.
  */
  username: string;
  /**
   * password to connect to apple store.
  */
  password: string;
  /**
   * The 6 digit Apple OTP for Multifactor accounts
  */
  authCode: string;
  /**
   * The app specific password required for app publishing for 2FA accounts
  */
  appSpecificPassword?: string;
}

/**
 * Apple connection secrets
*/
export interface AppleCredentialsMultifactorSecretRequest extends AppleConnectionSecretRequest {
  /**
   * apple secret details
  */
  data: AppleMultifactorSecretDetails;
}

/**
 * Apple secret details
*/
export interface AppleSecretDetails {
  /**
   * username to connect to apple store.
  */
  username?: string;
  /**
   * 6 digit auth code
  */
  authCode?: string;
  /**
   * password to connect to apple store.
  */
  password?: string;
}

/**
 * Apple connection secrets
*/
export interface AppleCredentialsSecretRequest extends AppleConnectionSecretRequest {
  /**
   * apple secret details
  */
  data: AppleSecretDetails;
}

/**
 * Apple Certificate Details
*/
export interface AppleCertificateDetails {
  /**
   * The certificate contents in base 64 encoded string
  */
  base64Certificate: string;
  /**
   * The password for the certificate
  */
  password: string;
}

/**
 * Apple certificate secrets
*/
export interface AppleCertificateSecretRequest extends AppleConnectionSecretRequest {
  /**
   * apple secret details
  */
  data: AppleCertificateDetails;
}

/**
 * private Apple connection secrets response
*/
export interface PrivateAppleSecretResponse extends PrivateSharedConnectionResponse {
}

/**
 * private Apple connection secrets response
*/
export interface PrivateAppleCredentialsSecretResponse extends PrivateAppleSecretResponse {
  /**
   * apple secret details
  */
  data: AppleSecretDetails;
}

/**
 * Apple Certificate Secret Details
*/
export interface AppleCertificateSecretDetails {
  /**
   * The certificate contents in base 64 encoded string
  */
  base64Certificate: string;
  /**
   * The password for the certificate
  */
  password: string;
  /**
   * The display name (CN) of the certificate
  */
  displayName: string;
  /**
   * The date-time from which the certificate is valid
  */
  certificateValidityStartDate: string;
  /**
   * The date-time till which the certificate is valid
  */
  certificateValidityEndDate: string;
}

/**
 * private Apple connection secrets response
*/
export interface PrivateAppleCertificateSecretResponse extends PrivateAppleSecretResponse {
  /**
   * apple secret details
  */
  data: AppleCertificateSecretDetails;
}

/**
 * Apple secret details
*/
export interface AppleSecretDetailsResponse {
  /**
   * username to connect to apple store
  */
  username: string;
}

/**
 * Apple connection secrets
*/
export interface AppleConnectionSecretResponse extends SharedConnectionResponse {
  /**
   * apple secret details
  */
  data: AppleSecretDetailsResponse;
}

/**
 * Apple connection secrets
*/
export interface AppleConnectionNonSecretResponse extends SharedConnectionResponse {
}

/**
 * Apple credentials non-secret details
*/
export interface AppleCredentialNonSecretDetailsResponse extends AppleConnectionNonSecretResponse {
  /**
   * Apple credentials non-secret data
  */
  data: AppleSecretDetailsResponse;
}

/**
 * Apple Certificate Secret Details
*/
export interface AppleCertificateNonSecretDetails {
  /**
   * The display name (CN) of the certificate
  */
  displayName: string;
  /**
   * The date-time from which the certificate is valid
  */
  certificateValidityStartDate: string;
  /**
   * The date-time till which the certificate is valid
  */
  certificateValidityEndDate: string;
}

/**
 * Apple certificate non-secret details
*/
export interface AppleCertificateNonSecretDetailsResponse extends AppleConnectionNonSecretResponse
{
  /**
   * apple certificate non-secret details
  */
  data: AppleCertificateNonSecretDetails;
}

/**
 * Apple connection secrets
*/
export interface AppleCertificateSecretDetailsResponse extends SharedConnectionResponse {
  /**
   * apple certificate secret details.
  */
  data: AppleCertificateSecretDetails;
}

/**
 * Jira secret details
*/
export interface JiraSecretDetails {
  /**
   * baseUrl to connect to jira instance
  */
  baseUrl: string;
  /**
   * username to connect to jira instance
  */
  username: string;
  /**
   * password to connect to jira instance
  */
  password: string;
}

/**
 * Jira connection secrets
*/
export interface JiraConnectionSecretRequest extends SharedConnectionRequest {
  /**
   * jira secret details
  */
  data: JiraSecretDetails;
}

/**
 * Jira secret details
*/
export interface JiraSecretDetailsResponse {
  /**
   * baseUrl to connect to jira instance
  */
  baseUrl: string;
  /**
   * username to connect to jira instance
  */
  username: string;
}

/**
 * Jira connection secrets
*/
export interface JiraConnectionSecretResponse extends SharedConnectionResponse {
  /**
   * jira secret details
  */
  data: JiraSecretDetailsResponse;
}

/**
 * private Jira connection secrets response
*/
export interface PrivateJiraConnectionSecretResponse extends PrivateSharedConnectionResponse {
  /**
   * jira secret details
  */
  data: JiraSecretDetails;
}

/**
 * Google Play connection secrets this should be the JSON file data which is provided by google
 * play
*/
export interface GooglePlayConnectionSecretRequest extends SharedConnectionRequest {
  /**
   * google secret details
  */
  data: any;
}

/**
 * Google Play connection secrets
*/
export interface GooglePlayConnectionSecretResponse extends SharedConnectionResponse {
  /**
   * google play secret details
  */
  data: any;
}

/**
 * private google connection secrets response
*/
export interface PrivateGooglePlayConnectionSecretResponse extends PrivateSharedConnectionResponse
{
  /**
   * google secret details
  */
  data: any;
}

/**
 * Google Play non-secret data
*/
export interface GooglePlayConnectionNonSecretResponse extends SharedConnectionResponse {
}

/**
 * Google Play credentials non-secret details
*/
export interface GooglePlayCredentialNonSecretDetailsResponse extends
GooglePlayConnectionNonSecretResponse {
  /**
   * Google Play credentials non-secret details
  */
  data: any;
}

/**
 * Jira non-secret data
*/
export interface JiraConnectionNonSecretResponse extends SharedConnectionResponse {
}

/**
 * Jira credentials non-secret details
*/
export interface JiraCredentialNonSecretDetailsResponse extends
GooglePlayConnectionNonSecretResponse {
  /**
   * Jira credentials non-secret details
  */
  data: JiraSecretDetailsResponse;
}

export interface ApiTokenResponsev2 {
  /**
   * The unique id (UUID) of the api token
  */
  id: string;
  /**
   * The creation time
  */
  createdAt: string;
  /**
   * The token's scope. A list of allowed roles.
  */
  scope?: string[];
  /**
   * The encrypted value of a token. This value will only be returned for token of type
   * in_app_update.
  */
  encryptedToken?: string;
  /**
   * The description of the token
  */
  description?: string;
}

export interface UserDataResponse {
  /**
   * The unique id (UUID) of the user
  */
  id?: string;
  /**
   * The display name of the user
  */
  displayName?: string;
  /**
   * The name of the user
  */
  name?: string;
  /**
   * The url at which the user's avatar can be reached
  */
  avatarUrl?: string;
}

export interface ErrorDetailsv2 {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized'
  */
  code: string;
  message: string;
}

export interface ErrorResponsev2 {
  error: ErrorDetailsv2;
}

export interface FileAsset {
  id?: string;
  location?: string;
  token?: string;
  uploadDomain?: string;
  uploadWindowLocation?: string;
  urlEncodedToken?: string;
}

/**
 * The source repository
*/
export interface SourceRepository {
  /**
   * The repository name
  */
  name?: string;
  /**
   * URL used to clone the repository
  */
  cloneUrl?: string;
}

/**
 * The GitHub Installation
*/
export interface GitHubAccountLite {
  /**
   * GitHub Account Id
  */
  id?: string;
  /**
   * GitHub Account Login Name
  */
  login?: string;
  /**
   * GitHub Account Type
  */
  type?: string;
  /**
   * GitHub Account Url
  */
  url?: string;
}

/**
 * The GitHub Installation
*/
export interface GitHubInstallationLite {
  /**
   * GitHub Installation Id
  */
  id?: number;
  account?: GitHubAccountLite;
  /**
   * GitHub Installation App Id
  */
  appId?: number;
}

/**
 * The repository which is accessiable by GitHub App Installation
*/
export interface GitHubInstallationRepository {
  /**
   * The repository name
  */
  name?: string;
  /**
   * The discription of repository
  */
  description?: string;
  /**
   * URL used to clone the repository
  */
  cloneUrl?: string;
  /**
   * The default branch for the repo
  */
  defaultBranch?: string;
  /**
   * The language in the repository
  */
  language?: string;
  /**
   * The repository updated time
  */
  updatedAt?: string;
  /**
   * Whether the repository is a fork
  */
  fork?: boolean;
}

/**
 * App Center account details from GitHub billing
*/
export interface GitHubBillingAccount {
  /**
   * The unique id (UUID) of the account
  */
  id: string;
  /**
   * The account's display name
  */
  displayName: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

/**
 * The lite version of GitHub repository
*/
export interface GitHubRepositoryLite {
  /**
   * The repository id
  */
  id?: number;
}

/**
 * The lite version of GitHub branch
*/
export interface GitHubBranchLite {
  /**
   * The repository name
  */
  ref?: string;
  /**
   * The discription of repository
  */
  sha?: string;
  repo?: GitHubRepositoryLite;
}

/**
 * The lite version of GitHub pull request
*/
export interface GitHubPullRequestLite {
  head?: GitHubBranchLite;
  base?: GitHubBranchLite;
}

/**
 * App extension information
*/
export interface IosAppExtensionInfo {
  /**
   * App extension name
  */
  name: string;
  /**
   * App extension bundle identifier
  */
  targetBundleIdentifier: string;
}

/**
 * Provisioning profile fetch and store information
*/
export interface ProvisioningProfileFile {
  /**
   * Name of uploaded provisioning profile
  */
  fileName?: string;
  /**
   * File id from secure file storage
  */
  fileId?: string;
  /**
   * Upload id to App Center File Upload Store
  */
  uploadId?: string;
  /**
   * Target the provisioning profile is used to sign
  */
  targetBundleIdentifier?: string;
}

/**
 * VSTS user profile
*/
export interface VSTSProfile {
  /**
   * Profile id
  */
  id?: string;
  /**
   * Profile display name
  */
  displayName?: string;
  /**
   * Profile alias
  */
  publicAlias?: string;
  /**
   * Profile email
  */
  emailAddress?: string;
}

/**
 * VSTS project
*/
export interface VSTSProject {
  /**
   * Project id
  */
  id?: string;
  /**
   * Project name
  */
  name?: string;
  /**
   * Project description
  */
  description?: string;
  /**
   * Project URL
  */
  url?: string;
  /**
   * Project state
  */
  state?: string;
  /**
   * Project visibility
  */
  visibility?: string;
}

/**
 * VSTS account with projects list and user info
*/
export interface VSTSAccount {
  /**
   * Account id
  */
  accountId?: string;
  /**
   * Account uri
  */
  accountUri?: string;
  /**
   * Account name
  */
  accountName?: string;
  /**
   * Account type
  */
  accountType?: string;
  /**
   * Account status
  */
  accountStatus?: string;
  user?: VSTSProfile;
  /**
   * Account projects
  */
  projects?: VSTSProject[];
}

/**
 * A download reference
*/
export interface DownloadContainer {
  /**
   * Download URI
  */
  uri: string;
}

/**
 * A websocket reference
*/
export interface WebSocketContainer {
  /**
   * WebSocket URL
  */
  url: string;
}

export interface XcodeArchiveProject {
  /**
   * The Id of the target to archive
  */
  archiveTargetId: string;
  /**
   * The project to archive container name
  */
  projectName: string;
  /**
   * Full path of the target project
  */
  projectPath?: string;
}

export interface XcodeScheme {
  /**
   * Scheme name
  */
  name: string;
  /**
   * Does scheme have a test action?
  */
  hasTestAction: boolean;
  /**
   * Build configuration set in Archive action
  */
  archiveConfiguration?: string;
  archiveProject?: XcodeArchiveProject;
}

export interface XcodeSchemeContainer {
  /**
   * Path to project
  */
  path: string;
  /**
   * Project schemes
  */
  sharedSchemes: XcodeScheme[];
  /**
   * Path to CocoaPods file, if present
  */
  podfilePath?: string;
  /**
   * Path to Carthage file, if present
  */
  cartfilePath?: string;
  /**
   * repo object Id of the pbxproject
  */
  xcodeProjectSha?: string;
  /**
   * Related projects paths for xcworkspace
  */
  workspaceProjectPaths?: string;
  /**
   * Information regarding project app extensions, if present
  */
  appExtensionTargets?: IosAppExtensionInfo[];
}

export interface XcodeToolset {
  /**
   * The Xcode scheme containers
  */
  xcodeSchemeContainers: XcodeSchemeContainer[];
}

export interface XamarinSolution {
  /**
   * Path to solution
  */
  path: string;
  /**
   * Solution configurations
  */
  configurations: string[];
  /**
   * Solution default configuration
  */
  defaultConfiguration?: string;
}

export interface XamarinToolset {
  /**
   * Xamarin solutions for the toolset
  */
  xamarinSolutions: XamarinSolution[];
}

export interface AndroidModule {
  /**
   * Name of the Android module
  */
  name: string;
  /**
   * The product flavors of the Android module
  */
  productFlavors?: string[];
  /**
   * The detected build variants of the Android module (matrix of product flavor + build type
   * (debug|release))
  */
  buildVariants?: string[];
  /**
   * The detected build types fo the Android module
  */
  buildTypes?: string[];
  /**
   * Whether the module is at the root level of the project
  */
  isRoot?: boolean;
}

export interface AndroidProject {
  /**
   * Android Gradle modules
  */
  androidModules: AndroidModule[];
  /**
   * The path of the Gradle wrapper
  */
  gradleWrapperPath?: string;
}

export interface JavaScriptSolution {
  /**
   * The path to the detected package.json
  */
  packageJsonPath: string;
  /**
   * Version of React Native from package.json files
  */
  reactNativeVersion?: string;
}

export interface JavaScriptToolset {
  /**
   * Paths for detected package.json files
  */
  packageJsonPaths: string[];
  /**
   * The React Native solutions detected
  */
  javascriptSolutions?: JavaScriptSolution[];
}

export interface UWPSolution {
  /**
   * The path to the UWP solution
  */
  path: string;
  /**
   * The possible configurations detected for the UWP solution
  */
  configurations: string[];
}

export interface UWPToolset {
  /**
   * The UWP solutions detected
  */
  uwpSolutions: UWPSolution[];
}

export interface TestCloudProjectFrameworkProperties {
  configurations?: string[];
}

export interface TestCloudProject {
  /**
   * The path to the TestCloud project
  */
  path: string;
  /**
   * Possible values include: 'Appium', 'Calabash', 'Espresso', 'UITest', 'Generated'
  */
  frameworkType: string;
  frameworkProperties?: TestCloudProjectFrameworkProperties;
}

export interface TestCloudToolset {
  /**
   * The TestCloud projects detected
  */
  projects: TestCloudProject[];
}

/**
 * Abstract platform project
*/
export interface ToolsetProject {
  name?: string;
  path?: string;
}

/**
 * A collection of projects for each type of toolset
*/
export interface ToolsetProjects {
  /**
   * The commit hash of the analyzed commit
  */
  commit?: string;
  xcode?: XcodeToolset;
  javascript?: JavaScriptToolset;
  xamarin?: XamarinToolset;
  android?: AndroidProject;
  buildscripts?: { [propertyName: string]: ToolsetProject };
  uwp?: UWPToolset;
  testcloud?: TestCloudToolset;
}

export interface Commit {
  /**
   * The commit SHA
  */
  sha?: string;
  /**
   * The URL to the commit
  */
  url?: string;
}

export interface Branch {
  /**
   * The branch name
  */
  name: string;
  commit: Commit;
}

/**
 * The branch build core properties
*/
export interface BranchProperties {
  branch?: Branch;
  enabled?: boolean;
}

export interface Build {
  /**
   * The build ID
  */
  id: number;
  /**
   * The build number
  */
  buildNumber: string;
  /**
   * The time the build was queued
  */
  queueTime: string;
  /**
   * The time the build was started
  */
  startTime?: string;
  /**
   * The time the build was finished
  */
  finishTime?: string;
  /**
   * The time the build status was last changed
  */
  lastChangedDate?: string;
  /**
   * The build status
  */
  status: string;
  /**
   * The build result
  */
  result: string;
  /**
   * The source branch name
  */
  sourceBranch: string;
  /**
   * The source SHA
  */
  sourceVersion: string;
}

/**
 * The branch build status
*/
export interface BranchStatus {
  configured: boolean;
  lastBuild?: Build;
  /**
   * Describes unknown properties. The value of an unknown property MUST be of type
   * "BranchProperties". Due to valid TS constraints we have modeled this as a union of
   * `BranchProperties | any`.
  */
  [additionalPropertyName: string]: BranchProperties | any;
}

/**
 * Build configuration when Xcode is part of the build steps
*/
export interface XcodeBranchConfigurationProperties {
  /**
   * Xcode project/workspace path
  */
  projectOrWorkspacePath: string;
  /**
   * Path to CococaPods file, if present
  */
  podfilePath?: string;
  /**
   * Path to Carthage file, if present
  */
  cartfilePath?: string;
  provisioningProfileEncoded?: string;
  certificateEncoded?: string;
  provisioningProfileFileId?: string;
  certificateFileId?: string;
  provisioningProfileUploadId?: string;
  appExtensionProvisioningProfileFiles?: ProvisioningProfileFile[];
  certificateUploadId?: string;
  certificatePassword?: string;
  scheme: string;
  xcodeVersion: string;
  provisioningProfileFilename?: string;
  certificateFilename?: string;
  teamId?: string;
  automaticSigning?: boolean;
  /**
   * The selected pbxproject hash to the repositroy
  */
  xcodeProjectSha?: string;
  /**
   * The build configuration of the target to archive
  */
  archiveConfiguration?: string;
  /**
   * The target id of the selected scheme to archive
  */
  targetToArchive?: string;
}

/**
 * Build configuration when React Native, or other JavaScript tech, is part of the build steps
*/
export interface JavaScriptBranchConfigurationProperties {
  /**
   * Path to package.json file for the main project, e.g. "package.json" or "myapp/package.json"
  */
  packageJsonPath: string;
  /**
   * Whether to run Jest unit tests, via npm test, during the build
  */
  runTests?: boolean;
  /**
   * Version of React Native from package.json files
  */
  reactNativeVersion?: string;
}

/**
 * Build configuration for Xamarin projects
*/
export interface XamarinBranchConfigurationProperties {
  slnPath: string;
  isSimBuild: string;
  args: string;
  configuration: string;
  p12File: string;
  p12Pwd: string;
  provProfile: string;
  monoVersion?: string;
  sdkBundle?: string;
  /**
   * Symlink of the SDK Bundle and Mono installation.
   * The build will use the associated Mono bundled with related Xamarin SDK. If both symlink and
   * monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink
   * is passed, the current stable Mono version will be configured for building.

  */
  symlink?: string;
}

/**
 * Build configuration for Android projects
*/
export interface AndroidBranchConfigurationProperties {
  /**
   * Path to the Gradle wrapper script
  */
  gradleWrapperPath?: string;
  /**
   * The Gradle module to build
  */
  module: string;
  /**
   * The Android build variant to build
  */
  buildVariant: string;
  /**
   * Whether to run unit tests during the build (default)
  */
  runTests?: boolean;
  /**
   * Whether to run lint checks during the build (default)
  */
  runLint?: boolean;
  /**
   * Whether it is the root module or not
  */
  isRoot?: boolean;
  /**
   * Whether to apply automatic signing or not
  */
  automaticSigning?: boolean;
  /**
   * The password of the keystore
  */
  keystorePassword?: string;
  /**
   * The key alias
  */
  keyAlias?: string;
  /**
   * The key password
  */
  keyPassword?: string;
  /**
   * The name of the keystore file
  */
  keystoreFilename?: string;
  /**
   * The keystore encoded value
  */
  keystoreEncoded?: string;
}

/**
 * The branch build configuration for each toolset
*/
export interface BranchConfigurationToolsets {
  xcode?: XcodeBranchConfigurationProperties;
  javascript?: JavaScriptBranchConfigurationProperties;
  xamarin?: XamarinBranchConfigurationProperties;
  android?: AndroidBranchConfigurationProperties;
}

/**
 * The versioning configuration for artifacts built for this branch
*/
export interface BranchConfigurationArtifactVersioning {
  /**
   * Possible values include: 'buildId', 'timestamp'
  */
  buildNumberFormat?: string;
}

/**
 * The branch build configuration
*/
export interface BranchConfiguration {
  id: number;
  /**
   * Possible values include: 'continous', 'continuous', 'manual'
  */
  trigger?: string;
  testsEnabled?: boolean;
  badgeIsEnabled?: boolean;
  signed?: boolean;
  toolsets?: BranchConfigurationToolsets;
  artifactVersioning?: BranchConfigurationArtifactVersioning;
  /**
   * Describes unknown properties. The value of an unknown property MUST be of type
   * "BranchProperties". Due to valid TS constraints we have modeled this as a union of
   * `BranchProperties | any`.
  */
  [additionalPropertyName: string]: BranchProperties | any;
}

export interface CommitDetailsCommitAuthor {
  /**
   * Date and time of the commit
  */
  date?: string;
  /**
   * Author name
  */
  name?: string;
  /**
   * Author's email
  */
  email?: string;
}

export interface CommitDetailsCommit {
  /**
   * Commit message
  */
  message?: string;
  author?: CommitDetailsCommitAuthor;
}

export interface CommitDetails extends Commit {
  commit?: CommitDetailsCommit;
}

export interface RepoConfig {
  /**
   * Type of repository
  */
  type: string;
  /**
   * State of the configuration. Possible values include: 'unauthorized', 'inactive', 'active'
  */
  state: string;
  /**
   * URL of the repository
  */
  repoUrl?: string;
  /**
   * Repository identifier
  */
  id?: string;
  /**
   * email of user, who linked repository
  */
  userEmail?: string;
  /**
   * The GitHub Installation id
  */
  installationId?: string;
}

export interface RepoInfo {
  /**
   * The repository url
  */
  repoUrl: string;
}

/**
 * The Xcode version
*/
export interface XcodeVersion {
  /**
   * The version name
  */
  name?: string;
  /**
   * If the Xcode is latest stable
  */
  current?: boolean;
}

/**
 * The Mono version
*/
export interface MonoVersion {
  /**
   * The version name
  */
  name?: string;
  /**
   * If the Mono is latest stable
  */
  current?: boolean;
}

/**
 * The Xamarin SDK bundle
*/
export interface XamarinSDKBundle {
  /**
   * The Mono version
  */
  monoVersion?: string;
  /**
   * The Xamarin SDK version
  */
  sdkBundle?: string;
  /**
   * If the SDK is latest stable
  */
  current?: boolean;
  /**
   * If the SDK is stable
  */
  stable?: boolean;
  /**
   * Specific for iOS SDK. A list of Xcode versions supported by current SDK version
  */
  xcodeVersions?: string[];
}

export interface BuildParams {
  /**
   * Version to build which represents the full Git commit reference
  */
  sourceVersion?: string;
  /**
   * Run build in debug mode
  */
  debug?: boolean;
}

export interface BuildPatch {
  /**
   * The build status; used to cancel builds. Possible values include: 'cancelling'
  */
  status?: string;
}

export interface BuildLog {
  value?: string[];
}

/**
 * Destination details for distributing build releases
*/
export interface DestinationDetails {
  id: string;
  /**
   * Possible values include: 'store', 'group', 'tester'
  */
  type: string;
}

export interface DistributionRequest {
  /**
   * Array of objects {id:string, type:string} with "id" being the distribution group ID, store ID,
   * or tester email, and "type" being "group", "store", or "tester"
  */
  destinations?: DestinationDetails[];
  /**
   * The release notes
  */
  releaseNotes?: string;
  mandatoryUpdate?: boolean;
  notifyTesters?: boolean;
}

export interface DistributionResponse {
  /**
   * Status of the Request
  */
  status?: string;
  /**
   * A unique ID of the upload
  */
  uploadId?: string;
}

export interface BuildServiceStatus {
  status?: string;
  service?: string;
  message?: string;
  url?: string;
  validUntil?: number;
  os?: string;
}

export interface BuildAgentQueue {
  queue: string;
}

export interface ValidationErrorResponse {
  id: string;
  code: string;
  message: string;
}

/**
 * Queue configured in build definition
*/
export interface BuildAgentQueueResponse {
  /**
   * Name of the build definition
  */
  buildDefinition?: string;
  /**
   * Name of the queue
  */
  name?: string;
}

/**
 * Agent queue
*/
export interface AgentQueueResponse {
  id?: number;
  name?: string;
}

/**
 * supported feature
*/
export interface AppBuildFeature {
  name?: string;
  value?: boolean;
}

/**
 * Additional details required for file validation
*/
export interface FileValidationDetails {
  p12password: string;
  certificateUploadId?: string;
}

/**
 * Number of pipelines
*/
export interface BuildConcurrencyResponse {
  /**
   * The number of pipelines set by the billing plan
  */
  quantity?: number;
  /**
   * The number of pipelines committed, which can be equal or greater than the number from the
   * billing plan
  */
  committedQuantity?: number;
}

export interface CreateReleaseUploadRequest {
  /**
   * The file extension of the uploaded file. Possible values include: 'ipa', 'apk', 'msi', 'xap',
   * 'appx', 'appxbundle', 'msix', 'msixbundle', 'appxupload', 'msixupload', 'app.zip', 'dmg',
   * 'pkg'
  */
  fileExtension: string;
}

export interface CreateReleaseUploadResponse {
  /**
   * The ID for the newly created upload. It is going to be required later in the process.
  */
  id: string;
  /**
   * The URL used to upload the release.
  */
  uploadUrl: string;
}

export interface GetReleaseStatusResponse {
  /**
   * The ID for the upload.
  */
  id: string;
  /**
   * The URL used to upload the release.
  */
  uploadUrl: string;
  /**
   * The current upload status. Possible values include: 'uploadStarted', 'uploadFinished',
   * 'readyToBePublished', 'malwareDetected', 'error'
  */
  uploadStatus: string;
  /**
   * Details describing what went wrong processing the upload. Will only be set if status =
   * 'error'.
  */
  errorDetails?: string;
  /**
   * The distinct ID of the release. Will only be set when the status = 'readyToBePublished'.
  */
  releaseDistinctId?: number;
  /**
   * The URL of the release. Will only be set when the status = 'readyToBePublished'.
  */
  releaseUrl?: any;
}

export interface PatchReleaseUploadStatusRequest {
  /**
   * The new status of the release upload. Possible values include: 'uploadFinished',
   * 'uploadCanceled'
  */
  uploadStatus: string;
}

export interface PatchReleaseUploadStatusResponse {
  /**
   * The ID for the upload.
  */
  id: string;
  /**
   * The current upload status. Possible values include: 'uploadStarted', 'uploadFinished',
   * 'uploadCanceled', 'readyToBePublished', 'malwareDetected', 'error'
  */
  uploadStatus: string;
}

/**
 * Response for getting a list of releases in a distribution group
*/
export interface DistributionGroupRelease {
  /**
   * ID identifying this unique release.
  */
  id?: number;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  version?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion?: string;
  /**
   * A boolean which determines whether the release is a mandatory update or not.
  */
  mandatoryUpdate?: boolean;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt?: string;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled?: boolean;
}

export interface TesterAppRelease extends DistributionGroupRelease {
  /**
   * The release's size in bytes.
  */
  size: number;
  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed
   * with `itms-services://?action=download-manifest&url=`
  */
  installUrl?: string;
  /**
   * The release's release notes.
  */
  releaseNotes?: string;
}

/**
 * The information about the app's owner
*/
export interface TesterAppWithReleaseResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id?: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName?: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name?: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type?: string;
}

export interface TesterAppWithReleaseResponse {
  /**
   * The unique ID (UUID) of the app
  */
  id?: string;
  release?: TesterAppRelease;
  /**
   * The app's name.
  */
  name?: string;
  /**
   * The app's display name.
  */
  displayName?: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * A URL to the app's icon.
  */
  iconUrl?: string;
  /**
   * The app's os.
  */
  os?: string;
  /**
   * The information about the app's owner
  */
  owner?: TesterAppWithReleaseResponseOwner;
}

export interface SendNotificationRequest {
  /**
   * user list to send email notification
  */
  userIds: string[];
}

/**
 * Response for retrieving user interaction metrics.
*/
export interface UserInteractionMetricsResponse {
  /**
   * check if the user has less than 100 apps.
  */
  lessThan100Apps?: boolean;
  /**
   * check if the user's whole apps has more than 1 releases.
  */
  hasMoreThan1Release?: boolean;
}

export interface ReleaseUpdateResponseDestinationsItem {
  id?: string;
  name?: string;
}

/**
 * Response for updating a release
*/
export interface ReleaseUpdateResponse {
  enabled?: boolean;
  mandatoryUpdate?: boolean;
  releaseNotes?: string;
  provisioningStatusUrl?: string;
  destinations?: ReleaseUpdateResponseDestinationsItem[];
}

/**
 * Response for updating release details
*/
export interface ReleaseDetailsUpdateResponse {
  releaseNotes?: string;
}

/**
 * Response for provisioning a release
*/
export interface ReleaseProvisionResponse {
  /**
   * The url to check provisioning status.
  */
  statusUrl?: string;
}

/**
 * Details of an uploaded release
*/
export interface PrivateReleaseDetailsResponse {
  /**
   * ID identifying this unique release.
  */
  id?: number;
  /**
   * OBSOLETE. Will be removed in next version. The availability concept is now replaced with
   * distributed. Any 'available' release will be associated with the default distribution group of
   * an app.</br>
   * The release state.<br>
   * <b>available</b>: The uploaded release has been distributed.<br>
   * <b>unavailable</b>: The uploaded release is not visible to the user. <br>
   * . Possible values include: 'available', 'unavailable'
  */
  status?: string;
  /**
   * The app's name (extracted from the uploaded release).
  */
  appName?: string;
  /**
   * The app's display name.
  */
  appDisplayName?: string;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.
   * For Android: android:versionCode from AppManifest.xml.

  */
  version?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion?: string;
  /**
   * The release's release notes.
  */
  releaseNotes?: string;
  /**
   * The release's provisioning profile name.
  */
  provisioningProfileName?: string;
  /**
   * The type of the provisioning profile for the requested app version. Possible values include:
   * 'adhoc', 'enterprise', 'other'
  */
  provisioningProfileType?: string;
  /**
   * A flag that determines whether the release's provisioning profile is still extracted or not.
  */
  isProvisioningProfileSyncing?: boolean;
  /**
   * The release's size in bytes.
  */
  size?: number;
  /**
   * The release's minimum required operating system.
  */
  minOs?: string;
  /**
   * The release's device family.
  */
  deviceFamily?: string;
  /**
   * The release's minimum required Android API level.
  */
  androidMinApiLevel?: string;
  /**
   * The identifier of the apps bundle.
  */
  bundleIdentifier?: string;
  /**
   * MD5 checksum of the release binary.
  */
  fingerprint?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt?: string;
  /**
   * The URL that hosts the binary for this release.
  */
  downloadUrl?: string;
  /**
   * A URL to the app's icon.
  */
  appIconUrl?: string;
  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed
   * with `itms-services://?action=download-manifest&url=`
  */
  installUrl?: string;
  /**
   * the destination where release is distributed
  */
  distributionGroupId?: string;
  /**
   * the publishing status of the distributed release
  */
  publishingStatus?: string;
  /**
   * The destination type.<br>
   * <b>group</b>: The release distributed to internal groups and distribution_groups details will
   * be returned.<br>
   * <b>store</b>: The release distributed to external stores and distribution_stores details will
   * be returned. <br>
   * . Possible values include: 'group', 'store'
  */
  destinationType?: string;
}

/**
 * Basic information on a release for private apis
*/
export interface PrivateBasicReleaseDetailsResponse {
  /**
   * ID identifying this unique release.
  */
  id?: number;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  version?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt?: string;
  /**
   * the destination id of release where it is distributed.
  */
  distributionGroupId?: string;
  /**
   * The destination type.<br>
   * <b>group</b>: The release distributed to internal groups and distribution_groups details will
   * be returned.<br>
   * <b>store</b>: The release distributed to external stores and distribution_stores details will
   * be returned. <br>
   * . Possible values include: 'group', 'store'
  */
  destinationType?: string;
  /**
   * Indicates if this is the latest release in the group.
  */
  isLatest?: boolean;
  /**
   * A boolean which determines whether the release is a mandatory update or not.
  */
  mandatoryUpdate?: boolean;
  /**
   * the publishing status of the distributed release
  */
  publishingStatus?: string;
}

/**
 * A unique identifier for a destination. A destination can be identified by an ID (guid) or by a
 * name. DestinationId encapsulates both options. A destination can be either a distribution group
 * or a store.
*/
export interface DestinationId {
  /**
   * Name of a distribution group / distribution store. The release will be associated with this
   * distribution group or store. If the distribution group / store doesn't exist a 400 is
   * returned. If both distribution group / store name and id are passed, the id is taking
   * precedence.
  */
  name?: string;
  /**
   * Id of a distribution group / store. The release will be associated with this distribution
   * group / store. If the distribution group / store doesn't exist a 400 is returned. If both
   * distribution group / store name and id are passed, the id is taking precedence.
  */
  id?: string;
}

export interface DistributionGroup extends DestinationId {
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
}

export interface DistributionStore extends DestinationId {
  /**
   * Is the containing release the latest one in this distribution store.
  */
  isLatest?: boolean;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'windows'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
}

export interface Destination {
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'windows'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
  /**
   * Name of a distribution group / distribution store. The release will be associated with this
   * distribution group or store. If the distribution group / store doesn't exist a 400 is
   * returned. If both distribution group / store name and id are passed, the id is taking
   * precedence.
  */
  name?: string;
  /**
   * Id of a distribution group / store. The release will be associated with this distribution
   * group / store. If the distribution group / store doesn't exist a 400 is returned. If both
   * distribution group / store name and id are passed, the id is taking precedence.
  */
  id?: string;
  /**
   * Destination can be either store or group. Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
}

/**
 * Contains metadata about the build that produced the release being uploaded
*/
export interface BuildInfo {
  /**
   * The branch name of the build producing the release
  */
  branch?: string;
  /**
   * The commit hash of the build producing the release
  */
  commitHash?: string;
  /**
   * The commit message of the build producing the release
  */
  commitMessage?: string;
}

/**
 * Basic information on a release
*/
export interface BasicReleaseDetailsResponse {
  /**
   * ID identifying this unique release.
  */
  id?: number;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  version?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion?: string;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled?: boolean;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt?: string;
  /**
   * OBSOLETE. Will be removed in next version. The destination type.<br>
   * <b>group</b>: The release distributed to internal groups and distribution_groups details will
   * be returned.<br>
   * <b>store</b>: The release distributed to external stores and distribution_stores details will
   * be returned. <br>
   * . Possible values include: 'group', 'store'
  */
  destinationType?: string;
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution groups that are associated
   * with this release.
  */
  distributionGroups?: DistributionGroup[];
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution stores that are associated
   * with this release.
  */
  distributionStores?: DistributionStore[];
  /**
   * A list of distribution groups or stores.
  */
  destinations?: Destination[];
  build?: BuildInfo;
}

export interface DistributionGroupWithoutIsLatest {
  /**
   * ID identifying a unique distribution group.
  */
  id?: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
}

export interface DistributionStoreWithoutIsLatest {
  /**
   * ID identifying a unique distribution store.
  */
  id?: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'windows'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
}

/**
 * Details of an uploaded release
*/
export interface ReleaseDetailsResponse {
  /**
   * ID identifying this unique release.
  */
  id?: number;
  /**
   * The app's name (extracted from the uploaded release).
  */
  appName?: string;
  /**
   * The app's display name.
  */
  appDisplayName?: string;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.
   * For Android: android:versionCode from AppManifest.xml.

  */
  version?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion?: string;
  /**
   * The release's release notes.
  */
  releaseNotes?: string;
  /**
   * The release's provisioning profile name.
  */
  provisioningProfileName?: string;
  /**
   * The type of the provisioning profile for the requested app version. Possible values include:
   * 'adhoc', 'enterprise', 'other'
  */
  provisioningProfileType?: string;
  /**
   * expiration date of provisioning profile in UTC format.
  */
  provisioningProfileExpiryDate?: string;
  /**
   * A flag that determines whether the release's provisioning profile is still extracted or not.
  */
  isProvisioningProfileSyncing?: boolean;
  /**
   * The release's size in bytes.
  */
  size?: number;
  /**
   * The release's minimum required operating system.
  */
  minOs?: string;
  /**
   * The release's device family.
  */
  deviceFamily?: string;
  /**
   * The release's minimum required Android API level.
  */
  androidMinApiLevel?: string;
  /**
   * The identifier of the apps bundle.
  */
  bundleIdentifier?: string;
  /**
   * MD5 checksum of the release binary.
  */
  fingerprint?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt?: string;
  /**
   * The URL that hosts the binary for this release.
  */
  downloadUrl?: string;
  /**
   * A URL to the app's icon.
  */
  appIconUrl?: string;
  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed
   * with `itms-services://?action=download-manifest&url=`
  */
  installUrl?: string;
  /**
   * OBSOLETE. Will be removed in next version. The destination type.<br>
   * <b>group</b>: The release distributed to internal groups and distribution_groups details will
   * be returned.<br>
   * <b>store</b>: The release distributed to external stores and distribution_stores details will
   * be returned.<br>
   * <b>tester</b>: The release distributed testers details will be returned.<br>
   * . Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution groups that are associated
   * with this release.
  */
  distributionGroups?: DistributionGroupWithoutIsLatest[];
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution stores that are associated
   * with this release.
  */
  distributionStores?: DistributionStoreWithoutIsLatest[];
  /**
   * A list of distribution groups or stores.
  */
  destinations?: Destination[];
  /**
   * In calls that allow passing `udid` in the query string, this value will hold the provisioning
   * status of that UDID in this release. Will be ignored for non-iOS platforms.
  */
  isUdidProvisioned?: boolean;
  /**
   * In calls that allow passing `udid` in the query string, this value determines if a release can
   * be re-signed. When true, after a re-sign, the tester will be able to install the release from
   * his registered devices. Will not be returned for non-iOS platforms.
  */
  canResign?: boolean;
  build?: BuildInfo;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled?: boolean;
}

/**
 * A response containing information pertaining to starting a release upload process
*/
export interface ReleaseUploadBeginResponse {
  /**
   * The ID for the current upload
  */
  uploadId: string;
  /**
   * The URL where the client needs to upload the release to
  */
  uploadUrl: string;
  /**
   * The ID for the current upload, reserved for future use
  */
  assetId?: string;
  /**
   * The URL for the current upload, reserved for future use
  */
  assetDomain?: string;
  /**
   * The token for the current upload, reserved for future use
  */
  assetToken?: string;
}

/**
 * A request containing a set of release ids to validate
*/
export interface GDPRValidationRequest {
  /**
   * a list of release ids to validate
  */
  releaseIds: number[];
}

/**
 * A request containing information pertaining to begin a release upload process
*/
export interface ReleaseUploadBeginRequest {
  /**
   * The ID of the release.
  */
  releaseId?: number;
  /**
   * The build version of the uploaded binary
  */
  buildVersion?: string;
}

/**
 * A request containing information pertaining to complete a release upload process
*/
export interface ReleaseUploadEndRequest {
  /**
   * The desired operation for the upload. Possible values include: 'committed', 'aborted'
  */
  status: string;
}

/**
 * A response containing information about the uploaded release.
*/
export interface ReleaseUploadEndResponse {
  /**
   * The ID of the release.
  */
  releaseId?: number;
  /**
   * A URL to the new release. If upload was aborted will be null.
  */
  releaseUrl?: string;
}

/**
 * An object containing a UUID for an architecture for an iOS app.
*/
export interface ArchIdentifier {
  /**
   * The architecture that the UUID belongs to, i.e. armv7 or arm64.
  */
  architecture: string;
  /**
   * The unique identifier.
  */
  uuid: string;
}

/**
 * An object containing information about an iOS provisioning profile.
*/
export interface ProvisioningProfile {
  /**
   * The name of the provisioning profile.
  */
  name: string;
  /**
   * The application identifier.
  */
  applicationIdentifier: string;
  /**
   * The team identifier.
  */
  teamIdentifier: string;
  /**
   * Possible values include: 'adhoc', 'enterprise', 'other'
  */
  profileType: string;
  /**
   * The profile's expiration date in RFC 3339 format, i.e. 2017-07-21T17:32:28Z
  */
  expiredAt: Date;
  udids?: string[];
}

/**
 * A request containing information for creating a release.
*/
export interface ReleaseCreateRequest {
  /**
   * The user that uploaded the build.
  */
  uploadedBy?: string;
  /**
   * The display name of the app, extracted from the build.
  */
  name: string;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  version: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  buildVersion: string;
  /**
   * The identifier of the app's bundle.
  */
  uniqueIdentifier: string;
  /**
   * The release's minimum required operating system.
  */
  minimumOsVersion: string;
  /**
   * The release's device family.
  */
  deviceFamily?: string;
  /**
   * The languages supported by the release.
  */
  languages?: string[];
  /**
   * MD5 checksum of the release binary.
  */
  fingerprint: string;
  /**
   * The release's size in bytes.
  */
  size: number;
  /**
   * The URL to the release's binary.
  */
  packageUrl: string;
  /**
   * The URL to the release's icon.
  */
  iconUrl?: string;
  /**
   * A list of UUIDs for architectures for an iOS app.
  */
  ipaUuids?: ArchIdentifier[];
  provision?: ProvisioningProfile;
  /**
   * iOS app extension provisioning profiles included in the release.
  */
  appexProvisioningProfiles?: ProvisioningProfile[];
}

/**
 * The response from the release creation API that just contains the created release's distinct id.
*/
export interface ReleaseCreateResponse {
  /**
   * The distinct ID of the release.
  */
  releaseDistinctId: number;
}

/**
 * A request containing information for updating a release.
*/
export interface ReleaseUpdateRequest {
  /**
   * OBSOLETE. Will be removed in future releases - use destinations instead. Name of a
   * distribution group. The release will be associated with this distribution group. If the
   * distribution group doesn't exist a 400 is returned. If both distribution group name and id are
   * passed, the id is taking precedence.

  */
  distributionGroupName?: string;
  /**
   * OBSOLETE. Will be removed in future releases - use destinations instead. Id of a distribution
   * group. The release will be associated with this distribution group. If the distribution group
   * doesn't exist a 400 is returned. If both distribution group name and id are passed, the id is
   * taking precedence.

  */
  distributionGroupId?: string;
  /**
   * OBSOLETE. Will be removed in future releases - use destinations instead. Name of a
   * destination. The release will be associated with this destination. If the destination doesn't
   * exist a 400 is returned. If both distribution group name and id are passed, the id is taking
   * precedence.

  */
  destinationName?: string;
  /**
   * OBSOLETE. Will be removed in future releases - use destinations instead. Id of a destination.
   * The release will be associated with this destination. If the destination doesn't exist a 400
   * is returned. If both destination name and id are passed, the id is taking precedence.

  */
  destinationId?: string;
  /**
   * Not used anymore.
  */
  destinationType?: string;
  /**
   * Release notes for this release.
  */
  releaseNotes?: string;
  /**
   * A boolean which determines whether this version should be a mandatory update or not.
  */
  mandatoryUpdate?: boolean;
  /**
   * Distribute this release under the following list of destinations (store groups or distribution
   * groups).
  */
  destinations?: DestinationId[];
  build?: BuildInfo;
  /**
   * A boolean which determines whether to notify testers of a new release, default to true.
  */
  notifyTesters?: boolean;
}

/**
 * A request containing information for updating details of a release
*/
export interface ReleaseDetailsUpdateRequest {
  /**
   * Toggle this release to be enable distribute/download or not.
  */
  enabled?: boolean;
  /**
   * Release notes for this release.
  */
  releaseNotes?: string;
  build?: BuildInfo;
}

export interface ReleaseStoreDestinationRequest {
  /**
   * Unique id of the release destination
  */
  id: string;
}

export interface ReleaseDestinationRequest extends ReleaseStoreDestinationRequest {
  /**
   * Flag to mark the release for the provided destinations as mandatory
  */
  mandatoryUpdate?: boolean;
  /**
   * Flag to enable or disable notifications to testers
  */
  notifyTesters?: boolean;
}

export interface ReleaseTesterDestinationRequest {
  /**
   * Flag to mark the release for the provided destinations as mandatory
  */
  mandatoryUpdate?: boolean;
  /**
   * Tester's email address
  */
  email: string;
  /**
   * Flag to enable or disable notifications to testers
  */
  notifyTesters?: boolean;
}

export interface ReleaseStoreDestinationResponse {
  /**
   * Unique id for the release destination
  */
  id: string;
}

export interface ReleaseDestinationResponse extends ReleaseStoreDestinationResponse {
  /**
   * Flag to mark the release for the provided destinations as mandatory
  */
  mandatoryUpdate: boolean;
  /**
   * The url to check provisioning status.
  */
  provisioningStatusUrl?: string;
}

/**
 * A request containing information for updating a release.
*/
export interface PrivateReleaseUpdateRequest {
  /**
   * The store publishing status. Possible values include: 'failed', 'processing', 'submitted'
  */
  publishingStatus?: string;
}

/**
 * A response containing information about an iOS provisioning profile.
*/
export interface ProvisioningProfileResponse {
  /**
   * Possible values include: 'adhoc', 'enterprise', 'other'
  */
  provisioningProfileType: string;
  udids?: string[];
  /**
   * The name of the provisioning profile.
  */
  provisioningProfileName?: string;
  /**
   * The team identifier.
  */
  teamIdentifier?: string;
  /**
   * The bundle identifier associated with the profile.
  */
  provisioningBundleId?: string;
  /**
   * Array of provisioning profiles for any app extensions
  */
  appexProfiles?: ProvisioningProfileResponse[];
}

export interface DestinationError {
  /**
   * Error Codes:<br>
   * <b>invalid_store_secrets</b>: While distributing to store, secrets provided for store are not
   * valid.<br>
   * <b>store_release_bad_request</b>: Proper package release details for the store is not
   * provided.<br>
   * <b>store_release_unauthorized</b>: User is not authorized to publish to store due to invalid
   * developer credentials.<br>
   * <b>store_release_forbidden</b>: Publish to store is forbidden due to conflicts/errors in the
   * release version and already existing version in the store.<br>
   * <b>store_release_promotion</b>: Release already distributed, promoting a release is not
   * supported.<br>
   * <b>store_track_deactivated</b>: One or more tracks would be deactivated with this release.
   * This is not supported yet.<br>
   * <b>store_release_not_found</b>: App with the given package name is not found in the store.<br>
   * <b>store_release_not_available</b>: The release is not available.<br>
   * <b>internal_server_error</b>: Failed to distribute to a destination due to an internal server
   * error.

  */
  code?: string;
  message?: string;
  id?: string;
  name?: string;
}

export interface ReleaseUpdateError extends ErrorDetails {
  releaseNotes?: string;
  mandatoryUpdate?: boolean;
  destinations?: DestinationError[];
}

/**
 * A request containing information for creating a Auto Provisioning Config.
*/
export interface AutoProvisioningConfigRequest {
  /**
   * A key to a secret in customer-credential-store. apple_developer_account refers to the user's
   * developer account that is used to log into https://developer.apple.com. Normally the user's
   * email.
  */
  appleDeveloperAccountKey?: string;
  /**
   * A key to a secret in customer-credential-store. distribution_certificate refers to the
   * customer's certificate (that holds the private key) that will be used to sign the app.
  */
  appleDistributionCertificateKey?: string;
  /**
   * When *true* enables auto provisioning
  */
  allowAutoProvisioning?: boolean;
}

/**
 * A response from API containing information for a Auto Provisioning Config.
*/
export interface AutoProvisioningConfigResponse {
  /**
   * The identifier of the config.
  */
  id?: number;
  /**
   * The identifier of the App.
  */
  appId?: string;
  /**
   * The identifier of the destination.
  */
  destinationId?: string;
  /**
   * A key to a secret in customer-credential-store. apple_developer_account refers to the user's
   * developer account that is used to log into https://developer.apple.com. Normally the user's
   * email.
  */
  appleDeveloperAccountKey?: string;
  /**
   * A key to a secret in customer-credential-store. distribution_certificate refers to the
   * cusomer's certificate (that holds the private key) that will be used to sign the app.
  */
  appleDistributionCertificateKey?: string;
  /**
   * When *true* enables auto provisioning
  */
  allowAutoProvisioning?: boolean;
}

export interface AnalyticsReleasesParameter {
  /**
   * release id
  */
  releaseId: number;
  /**
   * distribution group id
  */
  distributionGroupId: string;
  /**
   * user id
  */
  userId: string;
}

export interface AnalyticsReleasesResponse {
  releases?: AnalyticsReleasesParameter[];
}

export interface HockeyAppCompatibilityReleaseResponse {
  id?: number;
  shortversion?: string;
  version?: string;
  uploadedAt?: Date;
  appsize?: number;
  notes?: string;
  mandatory?: boolean;
  external?: boolean;
  deviceFamily?: string;
  minimumOsVersion?: string;
}

/**
 * Describes the migration schema for a provisioning profile defined in HockeyApp.
*/
export interface ProvisioningProfileMigration {
  /**
   * The name of the provisioning profile.
  */
  name: string;
  /**
   * The bundle/application identifier.
  */
  bundleId: string;
  /**
   * The team identifier.
  */
  teamIdentifier: string;
  /**
   * The type of provisoning profile.
  */
  type: number;
  /**
   * A boolean value that indicates whether the provisioning profile represents an app extension.
  */
  isAppex: boolean;
  /**
   * The provisioning profile's expiration date in RFC 3339 format, i.e. 2017-07-21T17:32:28Z.
  */
  expiredAt?: Date;
  /**
   * A list of UDIDs of provisioned devices.
  */
  udids?: string[];
  /**
   * A provisioning profile URL that indicates where to download it from.
  */
  url?: string;
}

/**
 * A single HockeyApp release to migrate to App Center
*/
export interface HockeyAppMigrationRelease {
  id?: number;
  shortversion?: string;
  version?: string;
  appsize?: number;
  minimumOsVersion?: string;
  md5Fingerprint?: string;
  createdAt?: Date;
  buildUrl?: string;
  bundleIdentifier?: string;
  deviceFamily?: string;
  languages?: string[];
  /**
   * For iOS apps, a dictionary of UUIDs for architectures (in format `{"armv7":
   * "353df799-d450-3308-8492-928ecf1ebf53", "arm64": "e67c0e93-b6d6-3f5a-b3a7-68d2b215bf27"}`)
  */
  uuids?: { [propertyName: string]: string };
  isExternalBuild?: boolean;
  mandatory?: boolean;
  /**
   * The status of the release in HockeyApp. Maps to HockeyAppSchema.AppVersionStatus. Possible
   * values: Deleted = -1, New = 0, Inactive = 1, Active = 2, Hidden = 3, SonomaActive = 4
  */
  status?: number;
  notes?: string;
  /**
   * List of DistributionGroup IDs the release is distributed to
  */
  distributionGroupIds?: string[];
  /**
   * List of User IDs the release is distributed to
  */
  distributionUserIds?: string[];
  provisioningProfiles?: ProvisioningProfileMigration[];
}

/**
 * A list of HockeyApp releases to migrate to App Center
*/
export interface MigrateReleaseRequest {
  releases?: HockeyAppMigrationRelease[];
}

/**
 * Details of the upload to patch
*/
export interface PrivateUpdateUploadDetails {
  /**
   * Possible values include: 'uploadStarted', 'uploadFinished', 'readyToBePublished',
   * 'malwareDetected', 'error'
  */
  status: string;
  /**
   * Message of the error
  */
  errorMessage: string;
}

/**
 * A response containing the fully encoded binary blob for a mobileconfig
*/
export interface DeviceConfigurationResponse {
  /**
   * A data URL containing a signed mobileconfig profile
  */
  dataUrl: string;
}

/**
 * The information for a single iOS device
*/
export interface DeviceInfoRequest {
  /**
   * The Unique Device IDentifier of the device
  */
  udid: string;
  /**
   * The model identifier of the device, in the format iDeviceM,N
  */
  model: string;
  /**
   * The build number of the last known OS version running on the device
  */
  osBuild?: string;
  /**
   * The last known OS version running on the device
  */
  osVersion?: string;
  /**
   * The device's serial number. Always empty or undefined at present.
  */
  serial?: string;
  /**
   * The device's International Mobile Equipment Identity number. Always empty or undefined at
   * present.
  */
  imei?: string;
  /**
   * The user ID of the device owner.
  */
  ownerId?: string;
}

/**
 * The information for a single iOS device
*/
export interface DeviceInfoResponse {
  /**
   * The Unique Device IDentifier of the device
  */
  udid: string;
  /**
   * The model identifier of the device, in the format iDeviceM,N
  */
  model: string;
  /**
   * The device description, in the format "iPhone 7 Plus (A1784)"
  */
  deviceName: string;
  /**
   * A combination of the device model name and the owner name.
  */
  fullDeviceName?: string;
  /**
   * The last known OS version running on the device
  */
  osBuild: string;
  /**
   * The last known OS version running on the device
  */
  osVersion: string;
  /**
   * The device's serial number. Always empty or undefined at present.
  */
  serial?: string;
  /**
   * The device's International Mobile Equipment Identity number. Always empty or undefined at
   * present.
  */
  imei?: string;
  /**
   * The user ID of the device owner.
  */
  ownerId?: string;
  /**
   * The provisioning status of the device.
  */
  status: string;
  /**
   * Timestamp of when the device was registered in ISO format.
  */
  registeredAt?: string;
}

/**
 * The status of the resign operation.
*/
export interface ResignStatus {
  /**
   * The status of the resign
  */
  status: string;
  /**
   * Error code for any error that occured during the resigning operation.
  */
  errorCode?: string;
  /**
   * Error message for any error that occured during the resigning operation.
  */
  errorMessage?: string;
}

/**
 * The information for a resign attempt.
*/
export interface ResignInfo {
  /**
   * The group name of the resign attempt
  */
  groupName?: string;
  /**
   * The provisioning profile name of group for the given resign attempt
  */
  profileName?: string;
  /**
   * The provisioning profile type of group for the given resign attempt
  */
  profileType?: string;
  /**
   * The name of the certificate used for the resign attempt
  */
  certificateName?: string;
  /**
   * The expiration date of the certificate used for the resign attempt
  */
  certificateExpiration?: string;
}

/**
 * The publising information.
*/
export interface PublishDevicesRequest {
  /**
   * The username for the Apple Developer account to publish the devices to.
  */
  username?: string;
  /**
   * The password for the Apple Developer account to publish the devices to.
  */
  password?: string;
  /**
   * The service_connection_id of the stored Apple credentials instead of username, password.
  */
  accountServiceConnectionId?: string;
  /**
   * When set to true, all unprovisioned devices will be published to the Apple Developer account.
   * When false, only the provided devices will be published to the Apple Developer account.
  */
  publishAllDevices?: boolean;
  /**
   * Array of device UDID's to be published to the Apple Developer account.
  */
  devices?: string[];
}

/**
 * The information for a single iOS device
*/
export interface PublishDevicesResponse {
  /**
   * The file name for the provisioning profile.
  */
  profileFileName?: string;
  /**
   * The updated provisioning profiles zip base64 encoded.
  */
  profilesZipBase64: string;
}

/**
 * Apple credentials needed to log into the Apple Developer Portal
*/
export interface AppleLoginRequest {
  /**
   * The username for the Apple Developer account.
  */
  username: string;
  /**
   * The password for the Apple Developer account.
  */
  password: string;
  /**
   * Identifier of the team to use when logged in.
  */
  teamIdentifier?: string;
  /**
   * The 30-day session cookie for multi-factor authentication backed accounts.
  */
  cookie?: string;
}

/**
 * Indicates if login was successful.
*/
export interface AppleLoginResponse {
  /**
   * True when login was successful.
  */
  successful?: boolean;
}

/**
 * Apple credentials needed to log into the Apple Developer Portal
*/
export interface AppleMutifactorLoginRequest {
  /**
   * The username for the Apple Developer account.
  */
  username: string;
  /**
   * This is the six digit OTP used for completing the multi-factor authentication
  */
  authcode: string;
}

/**
 * The response of Multifactor login. This is a 30 day session token generated by apple.
*/
export interface AppleMultifactorLoginResponse {
  /**
   * the apple developer account.
  */
  username?: string;
  /**
   * The 30-day session Token generated by apple after successfully logging in with Multifactor
   * authentication.
  */
  cookie?: string;
  /**
   * The expiry date of the cookie generated by apple
  */
  expires?: string;
}

/**
 * The information needed to fetch the status of an application
*/
export interface ApplicationStatusRequest {
  /**
   * The username for the Apple Developer account.
  */
  username: string;
  /**
   * The password for the Apple Developer account.
  */
  password: string;
  /**
   * Bundle Identifier of application in Apple Itunes portal.
  */
  bundleIdentifier: string;
  /**
   * Track Identifier for which the status is to be fetched.
  */
  trackIdentifier: string;
  /**
   * The version of build for which real time status is to be fetched.
  */
  buildVersion?: string;
  /**
   * Identifier of the team to use when logged in.
  */
  teamIdentifier?: string;
  /**
   * The Train version for which the status is to be fetched.
  */
  trainVersion?: string;
}

/**
 * The status information from Itunes portal
*/
export interface ApplicationStatusResponse {
  /**
   * The type of version being returned (production/edit/test flight).
  */
  versionType: string;
  /**
   * The version of the application
  */
  version?: string;
}

/**
 * Apple credentials with username, password or service_connection_id of the stored credentials is
 * needed along with team_identifier.
*/
export interface ItunesAppsRequest {
  /**
   * The username for the Apple Developer account.
  */
  username?: string;
  /**
   * The password for the Apple Developer account.
  */
  password?: string;
  /**
   * The service_connection_id of the stored Apple credentials instead of username, password.
  */
  serviceConnectionId?: string;
  /**
   * Identifier of the team to use when logged in.
  */
  teamIdentifier?: string;
  /**
   * The 30-day session cookie for multi-factor authentication backed accounts.
  */
  cookie?: string;
}

/**
 * Apple credentials with username, password or service_connection_id of the stored credentials is
 * needed.
*/
export interface ItunesTeamsRequest {
  /**
   * The username for the Apple Developer account.
  */
  username?: string;
  /**
   * The password for the Apple Developer account.
  */
  password?: string;
  /**
   * The service_connection_id of the stored Apple credentials instead of username, password.
  */
  serviceConnectionId?: string;
  /**
   * The 30-day session cookie for multi-factor authentication backed accounts.
  */
  cookie?: string;
}

/**
 * Itunes teams details .
*/
export interface ItunesTeamsResponse {
  /**
   * Itunes team id.
  */
  teamId?: string;
  /**
   * Itunes Team Name
  */
  teamName?: string;
}

/**
 * Itunes teams details .
*/
export interface AllItunesAppsResponse {
  /**
   * apple id for app team id.
  */
  appleId?: string;
  /**
   * bundle identifier of app
  */
  bundleId?: string;
  /**
   * App Name
  */
  name?: string;
  /**
   * url for the app icon from app store
  */
  iconUrl?: string;
}

/**
 * Apple details for fetching test flight groups from Apple Developer Portal. pass either apple_id
 * or bundle_identifier to get the test flight groups. if both are passed than apple_id will take
 * preference
*/
export interface AppleTestFlightGroupRequest {
  /**
   * The username for the Apple Developer account.
  */
  username?: string;
  /**
   * The password for the Apple Developer account.
  */
  password?: string;
  /**
   * apple_id of the app for which test flight groups need to be fetched.
  */
  appleId?: string;
  /**
   * apple_id of the app for which test flight groups need to be fetched.
  */
  bundleIdentifier?: string;
  /**
   * Identifier of the team to use when logged in.
  */
  teamIdentifier?: string;
  /**
   * The 30-day session cookie for multi-factor authentication backed accounts.
  */
  cookie?: string;
  /**
   * The service_connection_id of the stored Apple credentials instead of username, password.
  */
  serviceConnectionId?: string;
}

/**
 * test flight group details for the app.
*/
export interface AppleTestFlightGroupResponse {
  /**
   * id of the group.
  */
  id?: string;
  /**
   * provider id of the group.
  */
  providerId?: number;
  /**
   * apple id of the group.
  */
  appAdamId?: number;
  /**
   * name of the group.
  */
  name?: string;
  /**
   * true if group is in active state.
  */
  active?: boolean;
  /**
   * true if the group is an internal group.
  */
  isInternalGroup?: boolean;
}

/**
 * Apple credentials needed to log into the Apple Developer Portal and access provisioning profiles
*/
export interface AvailabilityOfDevicesRequest {
  /**
   * The username for the Apple Developer account.
  */
  username?: string;
  /**
   * The password for the Apple Developer account.
  */
  password?: string;
  /**
   * The service_connection_id of the stored Apple credentials instad of username, password.
  */
  serviceConnectionId?: string;
}

/**
 * ...
*/
export interface DeviceAvailability {
  registered: number;
  available: number;
  maximum: number;
}

/**
 * The current device availability (registered, available and maxmimum) for iPhones, iPads, iPods
 * and Watches from Apple Developer Portal
*/
export interface AvailabilityOfDevicesResponse {
  iphones: DeviceAvailability;
  ipads: DeviceAvailability;
  ipods: DeviceAvailability;
  watches: DeviceAvailability;
}

export interface UpdateDevicesRequestDestinationsItem {
  name?: string;
}

/**
 * Information required to publish devices to the Apple Developer account and resign the
 * application.
*/
export interface UpdateDevicesRequest {
  /**
   * When provided, will update the provided release with the new set of devices. By default the
   * latest release of the distribution group is used when this property is omitted. If
   * `release_id` is passed in the path, there is no need to pass in the body as well.
  */
  releaseId?: number;
  /**
   * The username for the Apple Developer account to publish the devices to.
  */
  username?: string;
  /**
   * The password for the Apple Developer account to publish the devices to.
  */
  password?: string;
  /**
   * The service_connection_id of the stored Apple credentials instead of username, password.
  */
  accountServiceConnectionId?: string;
  /**
   * The certificate to use for resigning the application with the updated provisioning profiles.
  */
  p12Base64?: string;
  /**
   * The service_connection_id of the stored Apple certificate instead of p12_base64 value.
  */
  p12ServiceConnectionId?: string;
  /**
   * The password certificate if one is needed.
  */
  p12Password?: string;
  /**
   * When set to true, all unprovisioned devices will be published to the Apple Developer account.
   * When false, only the provided devices will be published to the Apple Developer account.
  */
  publishAllDevices?: boolean;
  /**
   * Array of device UDID's to be published to the Apple Developer account.
  */
  devices?: string[];
  /**
   * Array of distribution groups that the devices should be provisioned from.
  */
  destinations?: UpdateDevicesRequestDestinationsItem[];
}

/**
 * URL that can be used to check the status of the update devices operation and the updated
 * profiles.
*/
export interface UpdateDevicesResponse {
  /**
   * URL that can be used to check the status of the update devices operation.
  */
  statusUrl: string;
}

/**
 * Updates the status of the resign request
*/
export interface UpdateResignStatusRequest {
  /**
   * The updated status for the resigning request.
  */
  status: string;
  /**
   * Error code if an error occured in the resigning operation.
  */
  errorCode?: string;
  /**
   * Error message if an error occured in the resigning operation.
  */
  errorMessage?: string;
}

/**
 * URL that can be used to check the status of the update devices operation and the updated
 * profiles.
*/
export interface UpdateResignStatusResponse {
  /**
   * The status.
  */
  status: string;
  /**
   * A zip of the updated provisioning profiles. Base64 encoded.
  */
  profilesZipBase64?: string;
}

/**
 * The url that can be navigated to in order to start the device registration process.
*/
export interface DeviceRegistrationUrl {
  /**
   * The url that can be navigated to in order to start the device registration process.
  */
  registrationUrl: string;
}

/**
 * URL that can be used to check the status of the update devices operation and the updated
 * profiles.
*/
export interface ResignAttemptResponse {
  /**
   * The status of the resigning operation.
  */
  status: string;
  /**
   * ID of the user performing the resign operaiton.
  */
  userId: string;
  /**
   * App ID that the resign operation is being performed against.
  */
  appId: string;
  /**
   * ID of the release which is being resigned.
  */
  originalReleaseId: number;
  /**
   * ID of the resign operation.
  */
  resignId: string;
  /**
   * Context ID for the resigning operation.
  */
  contextId: string;
  /**
   * The time that the resign operation was started.
  */
  startTime: number;
  /**
   * List of destinations that the resign operation is being performed against.
  */
  destinations?: any[];
  /**
   * Error code associated with the exception.
  */
  errorCode?: string;
  /**
   * Error message associated with the exception.
  */
  errorMessage?: string;
}

export interface StoresBasicDetails {
  /**
   * ID identifying a unique distribution store.
  */
  id?: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune or googleplay. Possible
   * values include: 'intune', 'googleplay'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
}

/**
 * Details of an uploaded release
*/
export interface StoresReleaseDetails {
  /**
   * ID identifying this unique release.
  */
  id?: number;
  /**
   * OBSOLETE. Will be removed in next version. The availability concept is now replaced with
   * distributed. Any 'available' release will be associated with the default distribution group of
   * an app.</br>
   * The release state.<br>
   * <b>available</b>: The uploaded release has been distributed.<br>
   * <b>unavailable</b>: The uploaded release is not visible to the user. <br>
   * . Possible values include: 'available', 'unavailable'
  */
  status?: string;
  /**
   * The app's name (extracted from the uploaded release).
  */
  appName?: string;
  /**
   * The app's display name.
  */
  appDisplayName?: string;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.
   * For Android: android:versionCode from AppManifest.xml.

  */
  version?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion?: string;
  /**
   * The release's release notes.
  */
  releaseNotes?: string;
  /**
   * The release's size in bytes.
  */
  size?: number;
  /**
   * The release's minimum required operating system.
  */
  minOs?: string;
  /**
   * The release's minimum required Android API level.
  */
  androidMinApiLevel?: string;
  /**
   * The identifier of the apps bundle.
  */
  bundleIdentifier?: string;
  /**
   * MD5 checksum of the release binary.
  */
  fingerprint?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt?: string;
  /**
   * The URL that hosts the binary for this release.
  */
  downloadUrl?: string;
  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed
   * with `itms-services://?action=download-manifest&url=`. Possible values include: 'group',
   * 'store'
  */
  installUrl?: string;
  /**
   * a list of distribution stores that are associated with this release.
  */
  distributionStores?: StoresBasicDetails[];
}

export interface StorePatchRequest {
  /**
   * Service connection id to updated.
  */
  serviceConnectionId: string;
}

export interface IntuneSecretDetails {
  /**
   * the id token of user
  */
  idToken?: string;
  /**
   * the refresh token for user
  */
  refreshToken?: string;
  /**
   * the expiry of refresh token
  */
  refreshTokenExpiry?: string;
}

export interface IntuneTargetAudience {
  /**
   * display name for the target audience/group
  */
  name?: string;
}

export interface IntuneAppCategory {
  /**
   * display name for the app category
  */
  name?: string;
}

export interface IntuneStoreRequest {
  secretJson?: IntuneSecretDetails;
  targetAudience?: IntuneTargetAudience;
  appCategory?: IntuneAppCategory;
  /**
   * tenant id of the intune store
  */
  tenantId?: string;
}

/**
 * ExternalStoreRequest
*/
export interface ExternalStoreRequest {
  /**
   * store Type. Possible values include: 'googleplay', 'intune', 'apple'
  */
  type?: string;
  /**
   * name of the store. In case of googleplay, and Apple store this is fixed to Production.
  */
  name?: string;
  /**
   * track of the store. Can be production, alpha & beta for googleplay. Can be production,
   * testflight-internal & testflight-external for Apple Store. Possible values include:
   * 'production', 'alpha', 'beta', 'testflight-internal', 'testflight-external'
  */
  track?: string;
  intuneDetails?: IntuneStoreRequest;
  /**
   * Id for the shared service connection. In case of Apple AppStore, this connection will be used
   * to create and connect to the Apple AppStore in Mobile Center.
  */
  serviceConnectionId?: string;
}

/**
 * Apple Mapping Request Type
*/
export interface AppleMappingRequest {
  /**
   * Id for the shared service connection. In case of Apple AppStore, this connection will be used
   * to create and connect to the Apple AppStore in Mobile Center.
  */
  serviceConnectionId: string;
  /**
   * ID of the apple application in apple store, takes precedence over bundle_identifier when both
   * are provided
  */
  appleId?: string;
  /**
   * Bundle Identifier of the apple package
  */
  bundleIdentifier?: string;
  /**
   * ID of the Team associated with the app in apple store
  */
  teamIdentifier: string;
}

/**
 * Apple Mapping Request Type
*/
export interface AppleMappingResponse {
  /**
   * ID of the apple application in Mobile Center
  */
  appId?: string;
  /**
   * Id for the shared service connection. In case of Apple AppStore, this connection will be used
   * to create and connect to the Apple AppStore in Mobile Center.
  */
  serviceConnectionId?: string;
  /**
   * ID of the apple application in apple store
  */
  appleId?: string;
  /**
   * ID of the Team associated with the app in apple store
  */
  teamIdentifier?: string;
}

/**
 * Apple Test Flight Groups Response Type
*/
export interface AppleTestFlightGroupsResponse {
  /**
   * id of the group.
  */
  id?: string;
  /**
   * provider id of the group.
  */
  providerId?: number;
  /**
   * apple id of the group.
  */
  appleId?: number;
  /**
   * name of the group.
  */
  name?: string;
}

export interface PrivateIntuneStoreRequest {
  targetAudience?: IntuneTargetAudience;
  appCategory?: IntuneAppCategory;
  /**
   * tenant id of the intune store
  */
  tenantId?: string;
}

/**
 * create the store through private API. Used by UI.
*/
export interface PrivateCreateStoreRequest {
  /**
   * store Type. Possible values include: 'intune'
  */
  type?: string;
  /**
   * name of the store.
  */
  name?: string;
  intuneDetails?: PrivateIntuneStoreRequest;
}

export interface IntuneCategoryValue {
  /**
   * the id of the category
  */
  id?: string;
  /**
   * the display name for the category
  */
  displayName?: string;
  /**
   * modified date for category
  */
  lastModifiedDateTime?: string;
}

export interface IntuneCategories {
  /**
   * context
  */
  odatacontext?: string;
  /**
   * categories for intune app
  */
  value?: IntuneCategoryValue[];
}

export interface IntuneGroupValue {
  /**
   * the id of the Group
  */
  id?: string;
  /**
   * the display name of the group
  */
  displayName?: string;
}

export interface IntuneGroups {
  /**
   * context
  */
  odatacontext?: string;
  /**
   * categories for intune app
  */
  value?: IntuneGroupValue[];
}

export interface IntuneGroup {
  /**
   * the id of the Group
  */
  id?: string;
  /**
   * the display name of the group
  */
  displayName?: string;
  /**
   * species if it is a security group
  */
  securityEnabled?: boolean;
}

export interface SecretDetails {
  /**
   * the id token of user
  */
  idToken?: string;
  /**
   * the refresh token for user
  */
  refreshToken?: string;
  /**
   * the expiry of refresh token
  */
  refreshTokenExpiry?: string;
}

export interface CreateStoreSecretRequest {
  secretJson?: SecretDetails;
  /**
   * the tenant id for user
  */
  tenantId?: string;
}

export interface CreateStoreSecretResponse {
  /**
   * the secret id for store secret
  */
  secretId?: string;
}

/**
 * ReleasePublishErrorResponse
*/
export interface ReleasePublishErrorResponse {
  /**
   * error Details
  */
  message?: string;
  /**
   * boolean property to tell if logs are available for download
  */
  isLogsAvailable?: boolean;
}

/**
 * Status Data from store
*/
export interface StatusData {
  /**
   * status from store
  */
  status?: string;
  /**
   * store type
  */
  storetype?: string;
  /**
   * track information from store
  */
  track?: string;
  /**
   * version of the app from store
  */
  version?: string;
}

/**
 * status of the app from store
*/
export interface ReleaseRealTimeStatusResponse {
  /**
   * release id
  */
  releaseId?: string;
  /**
   * app id
  */
  appId?: string;
  status?: StatusData;
}

/**
 * The response which contains the validation data that the connection is valid.
*/
export interface ValidationResponse {
  /**
   * app id
  */
  appId?: string;
  status?: StatusData;
}

/**
 * The response for the build uploaded check.
*/
export interface HasBuildUploadedResponse {
  /**
   * true if a build has been uploaded, false otherwise
  */
  hasBuildUploaded?: boolean;
}

/**
 * The response for the testflight metadata check.
*/
export interface HasTestflightMetadataResponse {
  /**
   * true if the app has the testflight metadata, false otherwise
  */
  hasTestflightMetadata?: boolean;
}

/**
 * Wheither or not to skip the validation for this release
*/
export interface SkipValidationRequest {
  /**
   * true if we want to skip the validation, false otherwise
  */
  skipValidation?: boolean;
}

export interface IntuneTargetAudienceResponse {
  /**
   * display name for the target audience/group
  */
  name?: string;
  /**
   * ID for the target audience/group.
  */
  id?: string;
}

export interface IntuneAppCategoryResponse {
  /**
   * display name for the app category
  */
  name?: string;
  /**
   * ID for the category.
  */
  id?: string;
}

export interface IntuneStoreResponse {
  targetAudience?: IntuneTargetAudienceResponse;
  appCategory?: IntuneAppCategoryResponse;
}

/**
 * ExternalStoreResponse
*/
export interface ExternalStoreResponse {
  /**
   * Store id
  */
  id?: string;
  /**
   * Store Name
  */
  name?: string;
  /**
   * Store Type
  */
  type?: string;
  /**
   * Store track. Possible values include: 'production', 'alpha', 'beta', 'testflight-internal',
   * 'testflight-external'
  */
  track?: string;
  /**
   * store details for intune
  */
  intuneDetails?: IntuneStoreResponse[];
  /**
   * Id for the shared service connection. In case of Apple / GooglePlay stores, this connection
   * will be used to connect to the Apple / Google stores in App Center.
  */
  serviceConnectionId?: string;
  /**
   * user id of the user who created the store.
  */
  createdBy?: string;
}

/**
 * StoreSecretResponse
*/
export interface StoreSecretResponse {
  /**
   * Store id
  */
  id?: string;
  /**
   * Store Name
  */
  name?: string;
  /**
   * Store Type
  */
  type?: string;
  /**
   * Secret Json
  */
  secret?: string;
  /**
   * Tenant Id for Intune
  */
  tenantId?: string;
}

export interface PatchReleaseRequest {
  /**
   * updated status of release
  */
  status?: string;
  /**
   * Destination Publish Id
  */
  destPublishId?: string;
  /**
   * failure error details from store
  */
  errorDetails?: string;
  /**
   * contextId for failed error message
  */
  errorContextId?: string;
  /**
   * package url for wrapping request
  */
  wrapPackageUrl?: string;
  /**
   * request is for wrapping or not
  */
  isWrapperRequest?: boolean;
}

export interface StoresDetails {
  /**
   * ID identifying a unique distribution store.
  */
  id?: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * A type identifying the type of distribution store. Possible values include: 'googleplay',
   * 'intune', 'apple'
  */
  type?: string;
  /**
   * A status identifying the status of release in the distribution store.
  */
  publishingStatus?: string;
  /**
   * Is the containing release the latest one in this distribution store.
  */
  isLatest?: boolean;
}

/**
 * Basic information on a release
*/
export interface StoresBasicReleaseDetails {
  /**
   * ID identifying this unique release.
  */
  id?: number;
  /**
   * The release's version.
   * For iOS: CFBundleVersion from info.plist.
   * For Android: android:versionCode from AppManifest.xml.

  */
  version?: string;
  /**
   * The release's short version.
   * For iOS: CFBundleShortVersionString from info.plist.
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt?: string;
  /**
   * a list of distribution stores that are associated with this release.
  */
  distributionStores?: StoresDetails[];
}

export interface StoreDestinationDetails {
  /**
   * destination ID identifying a unique id in distribution store.
  */
  destPublishId?: string;
  /**
   * type of store. Possible values include: 'intune'
  */
  storeType?: string;
  /**
   * app id of application.
  */
  appId?: string;
}

/**
 * IntuneAppsRequest
*/
export interface IntuneAppsRequest {
  /**
   * PartitionKey year-month
  */
  createdMonth?: string;
}

/**
 * IntuneAppsResponse
*/
export interface IntuneAppsResponse {
  /**
   * PartitionKey year-month
  */
  createdMonth?: string;
  /**
   * App id
  */
  appId?: string;
  /**
   * Refresh Status
  */
  refreshStatus?: string;
}

/**
 * org settings Request
*/
export interface OrgComplianceSettingsRequest {
  /**
   * certificate connection id to wrap and resign the app after wrapping
  */
  certificateConnectionId: string;
}

/**
 * org settings response
*/
export interface OrgComplianceSettingsResponse {
  /**
   * The internal unique id (UUID) of the organization compliance setting
  */
  id: string;
  /**
   * The internal unique id (UUID) of the organization.
  */
  orgId: string;
  /**
   * certificate connection id to wrap and resign the app after wrapping
  */
  certificateConnectionId: string;
  /**
   * flag to tell if mam warpping is enabled on the Org
  */
  isMamEnabled?: boolean;
}

export interface StoreNotification {
  service?: string;
  status?: string;
  validUntil?: number;
}

/**
 * The diagnostic id for the given publish action
*/
export interface DiagnosticIdResponse {
  /**
   * diagnostic id
  */
  diagnosticId?: string;
}

export interface Symbol {
  /**
   * The unique id for this symbol (uuid)
  */
  symbolId: string;
  /**
   * The type of the symbol for the current symbol upload. Possible values include: 'Apple',
   * 'JavaScript', 'Breakpad', 'AndroidProguard', 'UWP'
  */
  type: string;
  /**
   * The application that this symbol belongs to
  */
  appId: string;
  /**
   * The platform that this symbol is associated with
  */
  platform: string;
  /**
   * The path name of the symbol file in blob storage
  */
  url: string;
  /**
   * The origin of the symbol file. Possible values include: 'System', 'User'
  */
  origin: string;
  /**
   * The other symbols in the same file
  */
  alternateSymbolIds: string[];
  /**
   * Whether the symbol is ignored. Possible values include: 'available', 'ignored'
  */
  status: string;
  /**
   * The version number. Optional for Apple. Required for Android.
  */
  version?: string;
  /**
   * The build number. Optional for Apple. Required for Android.
  */
  build?: string;
  /**
   * The id of the symbol upload this symbol belongs to.
  */
  symbolUploadId: string;
}

/**
 * A response containing information pertaining to a symbol status
*/
export interface SymbolStatusResponse {
  /**
   * The unique id for this symbol (uuid)
  */
  symbolId: string;
  /**
   * The application that this symbol belongs to
  */
  appId: string;
  /**
   * Whether the symbol is ignored. Possible values include: 'available', 'ignored', 'missing'
  */
  status: string;
}

export interface SymbolUploadUserInfo {
  /**
   * The email of the user
  */
  email?: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
}

export interface UploadedSymbolInfo {
  /**
   * The symbol id of the symbol binary
  */
  symbolId: string;
  /**
   * The platform the symbol is associated with
  */
  platform: string;
}

/**
 * A single symbol upload entity
*/
export interface SymbolUpload {
  /**
   * The id for the current symbol upload
  */
  symbolUploadId: string;
  /**
   * The application that this symbol upload belongs to
  */
  appId: string;
  /**
   * User information of the one who intitiated the symbol upload
  */
  user?: SymbolUploadUserInfo;
  /**
   * The current status for the symbol upload. Possible values include: 'created', 'committed',
   * 'aborted', 'processing', 'indexed', 'failed'
  */
  status: string;
  /**
   * The type of the symbol for the current symbol upload. Possible values include: 'Apple',
   * 'Breakpad', 'AndroidProguard', 'UWP'
  */
  symbolType: string;
  /**
   * The symbols found in the upload
  */
  symbolsUploaded?: UploadedSymbolInfo[];
  /**
   * The origin of the symbol upload. Possible values include: 'User', 'System'
  */
  origin?: string;
  /**
   * The file name for the symbol upload
  */
  fileName?: string;
  /**
   * The size of the file in Mebibytes
  */
  fileSize?: number;
  /**
   * When the symbol upload was committed, or last transaction time if not committed
  */
  timestamp?: Date;
}

/**
 * Location for downloading symbol
*/
export interface SymbolLocation {
  uri: string;
}

/**
 * Location for downloading symbol upload
*/
export interface SymbolUploadLocation {
  uri: string;
}

/**
 * A request containing information pertaining to starting a symbol upload process
*/
export interface SymbolUploadBeginRequest {
  /**
   * The type of the symbol for the current symbol upload. Possible values include: 'Apple',
   * 'Breakpad', 'AndroidProguard', 'UWP'
  */
  symbolType: string;
  /**
   * The callback URL that the client can optionally provide to get status updates for the current
   * symbol upload
  */
  clientCallback?: string;
  /**
   * The file name for the symbol upload
  */
  fileName?: string;
  /**
   * The build number. Optional for Apple. Required for Android.
  */
  build?: string;
  /**
   * The version number. Optional for Apple. Required for Android.
  */
  version?: string;
}

/**
 * A response containing information pertaining to starting a symbol upload process
*/
export interface SymbolUploadBeginResponse {
  /**
   * The id for the current upload
  */
  symbolUploadId: string;
  /**
   * The URL where the client needs to upload the symbol blob to
  */
  uploadUrl: string;
  /**
   * Describes how long the upload_url is valid
  */
  expirationDate: Date;
}

/**
 * A request containing information pertaining to completing a symbol upload process
*/
export interface SymbolUploadEndRequest {
  /**
   * The desired operation for the symbol upload. Possible values include: 'committed', 'aborted'
  */
  status: string;
}

/**
 * A response represents information about symbol name group
*/
export interface SystemVersionNameGroup {
  /**
   * Name of version group
  */
  name?: string;
  versions?: string[];
}

export interface AppFeatures {
  /**
   * App supports modification of crashgroup status
  */
  crashgroupModifyStatus?: boolean;
  /**
   * App supports modification of crashgroup annotation
  */
  crashgroupModifyAnnotation?: boolean;
  /**
   * App supports search API
  */
  search?: boolean;
  /**
   * App supports the 'crash free user' metric
  */
  crashgroupAnalyticsCrashfreeusers?: boolean;
  /**
   * App supports the 'impacted users' metric
  */
  crashgroupAnalyticsImpactedusers?: boolean;
  /**
   * App supports download of raw crashes
  */
  crashDownloadRaw?: boolean;
}

export interface AppCrashesInfo {
  hasCrashes: boolean;
  features: AppFeatures;
}

export interface AppVersion {
  appVersionId: string;
  appId: string;
  displayName: string;
  appVersion: string;
  buildNumber?: string;
}

/**
 * a single frame of a stack trace
*/
export interface StackFrame {
  /**
   * address of the frame
  */
  address?: string;
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Raw frame string
  */
  codeRaw: string;
  /**
   * Formatted frame string
  */
  codeFormatted: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * frame should be shown always
  */
  relevant?: boolean;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
}

/**
 * a exception
*/
export interface Exception {
  /**
   * Reason of the exception
  */
  reason?: string;
  /**
   * Type of the exception (NSSomethingException, NullPointerException)
  */
  type?: string;
  /**
   * frames of the excetpion
  */
  frames: StackFrame[];
  /**
   * relevant exception (crashed)
  */
  relevant?: boolean;
  innerExceptions?: Exception[];
  /**
   * SDK/Platform this thread is beeing generated from. Possible values include: 'ios', 'android',
   * 'xamarin', 'react-native', 'ndk', 'unity', 'other'
  */
  platform?: string;
}

/**
 * a thread representation
*/
export interface Thread {
  /**
   * name of the thread
  */
  title: string;
  /**
   * frames of that thread
  */
  frames: StackFrame[];
  /**
   * potential additional exception happened in that thread (Last Exception Backtrace)
  */
  exception?: Exception;
  /**
   * Shows if a thread is relevant or not. Is false if all frames are non relevant, otherwise true
  */
  relevant?: boolean;
  /**
   * SDK/Platform this thread is beeing generated from. Possible values include: 'ios', 'android',
   * 'xamarin', 'react-native', 'ndk', 'unity', 'other'
  */
  platform?: string;
  /**
   * True if this thread crashed
  */
  crashed?: boolean;
}

/**
 * a stacktrace in a processed and prettyfied way
*/
export interface Stacktrace {
  title?: string;
  reason?: string;
  threads?: Thread[];
  exception?: Exception;
}

/**
 * frame belonging to the reason of the crash
*/
export interface ReasonStackFrame {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface RetentionSettings {
  retentionInDays: number;
}

export interface CrashAttachment {
  appId: string;
  attachmentId: string;
  crashId: string;
  blobLocation: string;
  contentType: string;
  fileName: string;
  createdTime: Date;
  size: number;
}

/**
 * Location for downloading crash raw
*/
export interface CrashRawLocation {
  uri: string;
}

/**
 * Location for downloading crash attachment
*/
export interface CrashAttachmentLocation {
  uri: string;
}

export interface CrashGroup {
  crashGroupId: string;
  newCrashGroupId: string;
  displayId: string;
  appVersion: string;
  build: string;
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  status: string;
  count: number;
  impactedUsers?: number;
  firstOccurrence: Date;
  lastOccurrence: Date;
  exception?: string;
  crashReason: string;
  reasonFrame?: ReasonStackFrame;
  /**
   * Crash or handled exception
  */
  fatal: boolean;
  annotation: string;
}

export interface CrashGroupsContainer {
  limitedResultSet: boolean;
  /**
   * Cassandra request continuation token. The token is used for pagination.
  */
  continuationToken?: string;
  crashGroups: CrashGroup[];
}

export interface CrashGroupChange {
  status?: any;
  annotation?: string;
}

export interface CrashDetails {
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCountry?: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * Whether the device where the crash occurred is rooted or jailbroken

  */
  rooted: boolean;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize: string;
  /**
   * Application launch timestamp (example: 1985-04-12T23:20:50.52Z).

  */
  appStartTimestamp?: Date;
}

export interface Crash {
  details?: CrashDetails;
  newCrashGroupId: string;
  crashId: string;
  newCrashId: string;
  displayId?: string;
  timestamp: Date;
  version: string;
  build: string;
  device: string;
  deviceName?: string;
  osVersion: string;
  osType?: string;
  stacktrace?: Stacktrace;
  userName: string;
  userEmail?: string;
}

export interface HockeyAppCrashForwardingInfo {
  forwardingEnabled: boolean;
}

export interface HockeyAppCrashForwardingChange {
  enableForwarding?: boolean;
}

export interface AlertingCrashGroup {
  url?: string;
  appDisplayName?: string;
  /**
   * SDK/Platform this thread is beeing generated from. Possible values include: 'ios', 'android',
   * 'xamarin', 'react-native', 'ndk', 'unity', 'other'
  */
  appPlatform?: string;
  appVersion?: string;
  id?: string;
  name?: string;
  reason?: string;
  stackTrace?: string[];
}

export interface CrashDeleteCounter {
  appId?: string;
  crashGroupId?: string;
  crashId?: string;
  crashesDeleted?: number;
  attachmentsDeleted?: number;
  blobsSucceeded?: number;
  blobsFailed?: number;
}

/**
 * missing symbol
*/
export interface V2MissingSymbol {
  /**
   * symbol id
  */
  symbolId: string;
  /**
   * symbol name
  */
  name: string;
  /**
   * symbol plarform
  */
  platform?: string;
  /**
   * symbol status. Possible values include: 'missing', 'ignored', 'available'
  */
  status: string;
}

/**
 * symbol update message
*/
export interface V2SymbolUpdateInfo {
  /**
   * UUID of the symbol
  */
  symbolId: string;
  /**
   * application id
  */
  appId: string;
  /**
   * symbol upload status. Possible values include: 'missing', 'ignored', 'available'
  */
  status: string;
}

/**
 * missing symbol crash group object
*/
export interface V2MissingSymbolCrashGroup {
  /**
   * id of the symbol group
  */
  symbolGroupId: string;
  /**
   * number of crashes that belong to this group
  */
  crashCount?: number;
  /**
   * application id
  */
  appId: string;
  /**
   * application version
  */
  appVer: string;
  /**
   * application build
  */
  appBuild: string;
  /**
   * last update date for the group
  */
  lastModified: Date;
  /**
   * list of missing symbols
  */
  missingSymbols: V2MissingSymbol[];
  /**
   * group status. Possible values include: 'active', 'pending', 'closed'
  */
  status: string;
}

/**
 * grouped by missing symbols crashes response object
*/
export interface V2MissingSymbolCrashGroupsResponse {
  /**
   * total number of cashes for all the groups
  */
  totalCrashCount: number;
  /**
   * list of crash groups formed by missing symbols combination
  */
  groups: V2MissingSymbolCrashGroup[];
}

/**
 * missing symbol groups
*/
export interface V2MissingSymbolCrashGroupsInfoResponse {
  /**
   * total number of crashes for all missing symbol groups
  */
  totalCrashCount: number;
}

/**
 * status response object
*/
export interface V2StatusResponse {
  status: string;
}

/**
 * failure response object
*/
export interface V2FailureResponse {
  code: string;
  message: string;
}

export interface CrashingAppDetail {
  /**
   * application identifier
  */
  appId?: string;
  /**
   * application version
  */
  appVersion?: string;
  /**
   * crash group identifier
  */
  crashGroupId?: string;
}

export interface ActiveCrashingAppDetails {
  nextLink?: string;
  /**
   * details of the apps with crashes
  */
  appsWithCrashes?: CrashingAppDetail[];
}

export interface LogTraceDefinition {
  appSecret: string;
  installId?: string;
  expiration?: Date;
}

/**
 * Device characteristics.
*/
export interface Device {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

export interface Log {
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  device: Device;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

export interface LogContainer {
  /**
   * indicates if the number of available logs are more than the max allowed return limit(100).
  */
  exceededMaxLimit?: boolean;
  /**
   * the timestamp of the last log received. This value can be used as the start time parameter in
   * the consecutive API call.
  */
  lastReceivedLogTimestamp?: Date;
  /**
   * the list of logs
  */
  logs: Log[];
}

/**
 * Generic log.
*/
export interface GenericLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Session ID.

  */
  sessionId?: string;
  /**
   * Event ID.

  */
  eventId?: string;
  /**
   * Event name.

  */
  eventName?: string;
  /**
   * Message ID.

  */
  messageId?: string;
  /**
   * event specific properties.

  */
  properties?: { [propertyName: string]: string };
  device: Device;
}

export interface GenericLogContainer {
  /**
   * indicates if the number of available logs are more than the max allowed return limit(100).
  */
  exceededMaxLimit?: boolean;
  /**
   * the timestamp of the last log received. This value can be used as the start time parameter in
   * the consecutive API call.
  */
  lastReceivedLogTimestamp?: Date;
  /**
   * the list of logs
  */
  logs: GenericLog[];
}

export interface LogWithProperties extends Log {
  /**
   * Additional key/value pair parameters.

  */
  properties?: { [propertyName: string]: string };
}

/**
 * Required explicit begin session log (a marker event for analytics service).
*/
export interface StartSessionLog extends Log {
  /**
   * Session ID.

  */
  sessionId: string;
}

/**
 * Required explicit begin session log (a marker event for analytics service).
*/
export interface HandledErrorLog extends Log {
  /**
   * Error ID.

  */
  errorId: string;
}

/**
 * Required explicit begin session log (a marker event for analytics service).
*/
export interface UnhandledErrorLog extends Log {
  /**
   * Error ID.

  */
  errorId: string;
}

/**
 * Describe a AppCenter.Start API call from the SDK.
*/
export interface StartServiceLog extends Log {
  /**
   * The list of services of the AppCenter Start API call.
  */
  services?: string[];
}

export interface CustomProperty {
  name: string;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Set or remove custom properties.
*/
export interface CustomPropertyLog extends Log {
  /**
   * Custom property changes.
  */
  properties?: CustomProperty[];
}

/**
 * String property.
*/
export interface StringProperty extends CustomProperty {
  /**
   * String property value.
  */
  value: string;
}

/**
 * Number property.
*/
export interface NumberProperty extends CustomProperty {
  /**
   * Number property value.
  */
  value: number;
}

/**
 * Boolean property.
*/
export interface BooleanProperty extends CustomProperty {
  /**
   * Boolean property value.
  */
  value: boolean;
}

/**
 * Date and time property.
*/
export interface DateTimeProperty extends CustomProperty {
  /**
   * Date time property value.
  */
  value: Date;
}

/**
 * Clear an existing property.
*/
export interface ClearProperty extends CustomProperty {
}

/**
 * Page view log (as in screens or activities).
*/
export interface PageLog extends LogWithProperties {
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Name of the page.

  */
  name: string;
}

/**
 * Event log.
*/
export interface EventLog extends LogWithProperties {
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Unique identifier for this event.

  */
  id: string;
  /**
   * Name of the event.

  */
  name: string;
}

/**
 * Push installation Information.
*/
export interface PushInstallationLog extends Log {
  /**
   * The PNS handle for this installation.

  */
  pushToken: string;
}

/**
 * Error log.
*/
export interface ErrorLog extends Log {
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Error identifier.
  */
  id: string;
  /**
   * Corresponds to the number of milliseconds elapsed between the time the error occurred and the
   * app was launched.

  */
  appLaunchToffset?: number;
}

/**
 * Audience definition.
*/
export interface AudienceSummary {
  /**
   * Audience name.
  */
  name?: string;
  /**
   * Audience description.
  */
  description?: string;
  /**
   * Estimated audience size.
  */
  estimatedCount?: number;
  /**
   * Audience definition in OData format.
  */
  definition?: string;
  /**
   * Audience state. Possible values include: 'Calculating', 'Ready', 'Disabled'
  */
  state?: string;
}

/**
 * List of audiences.
*/
export interface AudienceListResult {
  /**
   * List of audiences.
  */
  values: AudienceSummary[];
  nextLink?: string;
}

/**
 * Audience with details.
*/
export interface Audience extends AudienceSummary {
  enabled?: boolean;
  /**
   * Custom properties used in the definition.
  */
  customProperties?: { [propertyName: string]: string };
  /**
   * Estimated total audience size.
  */
  estimatedTotalCount?: number;
  /**
   * Date the audience was last refreshed.
  */
  timestamp?: Date;
}

/**
 * Audience test result.
*/
export interface AudienceTestResult {
  /**
   * Audience definition in OData format.
  */
  definition?: string;
  /**
   * Custom properties used in the definition.
  */
  customProperties?: { [propertyName: string]: string };
  /**
   * Estimated audience size.
  */
  estimatedCount?: number;
  /**
   * Estimated total audience size.
  */
  estimatedTotalCount?: number;
}

/**
 * Token query result.
*/
export interface TokenQueryResult {
  /**
   * List of tokens.
  */
  tokens?: string[];
}

/**
 * Audience definition.
*/
export interface AudienceDefinition {
  /**
   * Audience description.
  */
  description?: string;
  /**
   * Audience definition in OData format.
  */
  definition: string;
  enabled?: boolean;
  /**
   * Custom properties used in the definition.
  */
  customProperties?: { [propertyName: string]: string };
}

/**
 * Audience Query definition.
*/
export interface AudienceQueryDefinition {
  /**
   * Audience Query Type. Possible values include: 'broadcast', 'user_ids', 'account_ids',
   * 'install_ids'
  */
  queryType: string;
  /**
   * List of identifiers.
  */
  identifiers?: string[];
}

/**
 * Audience definition.
*/
export interface AudienceBlobResult {
  /**
   * Location of the audience blob.
  */
  url?: string;
}

/**
 * List of device properties.
*/
export interface AudienceDevicePropertiesListResult {
  /**
   * List of device properties.
  */
  values: { [propertyName: string]: string };
}

/**
 * List of device property values.
*/
export interface AudienceDevicePropertyValuesListResult {
  /**
   * List of device property values.
  */
  values: string[];
}

export interface DateTimeCounts {
  /**
   * the ISO 8601 datetime
  */
  datetime?: string;
  /**
   * count of the object
  */
  count?: number;
}

export interface CrashCounts {
  /**
   * total crash count
  */
  count?: number;
  /**
   * the total crash count for day
  */
  crashes?: DateTimeCounts[];
}

export interface ActiveDeviceCounts {
  /**
   * the active device count for each interval
  */
  daily?: DateTimeCounts[];
  /**
   * the active device count for each interval with a week's retention
  */
  weekly?: DateTimeCounts[];
  /**
   * the active device count for each interval with a month's retention
  */
  monthly?: DateTimeCounts[];
}

/**
 * The place code and the count
*/
export interface Place {
  /**
   * the place code
  */
  code?: string;
  /**
   * the count of the this place
  */
  count?: number;
  /**
   * the count of previous time range of the place
  */
  previousCount?: number;
}

/**
 * Places and count during the time range in descending order
*/
export interface Places {
  total?: number;
  places?: Place[];
}

export interface ErrorError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed
  */
  message?: string;
}

/**
 * Error
*/
export interface ErrorModel {
  error?: ErrorError;
}

export interface SessionDurationsDistributionDistributionItem {
  /**
   * the bucket name
  */
  bucket?: string;
  /**
   * the count of sessions in current bucket
  */
  count?: number;
}

export interface SessionDurationsDistribution {
  /**
   * the count of sessions in these buckets
  */
  distribution?: SessionDurationsDistributionDistributionItem[];
  /**
   * the previous average session duration for previous time range
  */
  previousAverageDuration?: string;
  /**
   * the average session duration for current time range
  */
  averageDuration?: string;
}

export interface Version {
  /**
   * version
  */
  version?: string;
  /**
   * version count
  */
  count?: number;
  /**
   * the count of previous time range of the version
  */
  previousCount?: number;
}

export interface Versions {
  /**
   * list of version count
  */
  versions?: Version[];
  /**
   * the total count of versions
  */
  total?: number;
}

export interface SessionsPerDeviceSessionsPerUserItem {
  /**
   * the ISO 8601 datetime
  */
  datetime?: string;
  /**
   * count
  */
  count?: number;
}

export interface SessionsPerDevice {
  /**
   * average seesion per user
  */
  averageSessionsPerUser?: number;
  /**
   * previous average session per user
  */
  previousAverageSessionsPerUser?: number;
  /**
   * total session per device count
  */
  totalCount?: number;
  /**
   * previous total count
  */
  previousTotalCount?: number;
  /**
   * the session count for each interval per device
  */
  sessionsPerUser?: SessionsPerDeviceSessionsPerUserItem[];
}

export interface Model {
  /**
   * model's name
  */
  modelName?: string;
  /**
   * count current of model
  */
  count?: number;
  /**
   * count of previous model
  */
  previousCount?: number;
}

export interface AnalyticsModels {
  total?: number;
  modelsProperty?: Model[];
}

export interface Language {
  /**
   * language's name
  */
  languageName?: string;
  /**
   * count current of language
  */
  count?: number;
  /**
   * count of previous lanugage
  */
  previousCount?: number;
}

export interface Languages {
  total?: number;
  languages?: Language[];
}

export interface OS {
  /**
   * OS name
  */
  osName?: string;
  /**
   * count current of OS
  */
  count?: number;
  /**
   * count of previous OS
  */
  previousCount?: number;
}

export interface OSes {
  total?: number;
  oses?: OS[];
}

export interface DateTimeDecimalCounts {
  /**
   * the ISO 8601 datetime
  */
  datetime?: string;
  /**
   * decimal count of the object
  */
  count?: number;
}

export interface AvailableVersions {
  /**
   * List of available versions.
  */
  versions?: string[];
  /**
   * The full number of versions across all pages.
  */
  totalCount?: number;
}

export interface DateTimePercentages {
  /**
   * the ISO 8601 datetime
  */
  datetime?: string;
  /**
   * percentage of the object
  */
  percentage?: number;
}

export interface CrashFreeDevicePercentages {
  /**
   * Average percentage
  */
  averagePercentage?: number;
  /**
   * The crash-free percentage per day.
  */
  dailyPercentages?: DateTimePercentages[];
}

export interface Modules {
  modules?: { [propertyName: string]: { [propertyName: string]: boolean } };
}

export interface CrashOverall {
  crashCount?: number;
  deviceCount?: number;
}

export interface CrashesOverallItem {
  crashGroupId?: string;
  appVersion?: string;
  overall?: CrashOverall;
}

export interface CrashGroupModel {
  /**
   * model's name
  */
  modelName?: string;
  /**
   * count of model
  */
  crashCount?: number;
}

export interface CrashGroupModels {
  crashCount?: number;
  modelsProperty?: CrashGroupModel[];
}

export interface CrashGroupOperatingSystem {
  /**
   * OS name
  */
  operatingSystemName?: string;
  /**
   * count of OS
  */
  crashCount?: number;
}

export interface CrashGroupOperatingSystems {
  crashCount?: number;
  operatingSystems?: CrashGroupOperatingSystem[];
}

export interface CrashGroupPlace {
  /**
   * Place name
  */
  placeName?: string;
  /**
   * count of places
  */
  crashCount?: number;
}

export interface CrashGroupPlaces {
  crashCount?: number;
  places?: CrashGroupPlace[];
}

export interface CrashGroupLanguage {
  /**
   * language name
  */
  languageName?: string;
  /**
   * count of languages
  */
  crashCount?: number;
}

export interface CrashGroupLanguages {
  crashCount?: number;
  languages?: CrashGroupLanguage[];
}

export interface CrashGroupCarrier {
  /**
   * carrier name
  */
  carrierName?: string;
  /**
   * crash count of carrier
  */
  crashCount?: number;
}

export interface CrashGroupCarriers {
  crashCount?: number;
  carriers?: CrashGroupCarrier[];
}

export interface CrashGroupAndVersion {
  crashGroupId?: string;
  appVersion?: string;
}

export interface CrashGroupContainer {
  crashGroups: CrashGroupAndVersion[];
}

export interface Event {
  id?: string;
  name?: string;
  deviceCount?: number;
  /**
   * the device count of previous time range of the event
  */
  previousDeviceCount?: number;
  count?: number;
  /**
   * the event count of previous time range of the event
  */
  previousCount?: number;
  countPerDevice?: number;
  countPerSession?: number;
}

export interface Events {
  events?: Event[];
  /**
   * the total count of events
  */
  total?: number;
  /**
   * the active device over this period
  */
  totalDevices?: number;
}

export interface EventCount {
  totalCount?: number;
  previousTotalCount?: number;
  count?: DateTimeCounts[];
}

export interface EventDeviceCount {
  totalDevices?: number;
  totalDevicesWithEvent?: number;
  previousTotalDevicesWithEvent?: number;
  devicesCount?: DateTimeCounts[];
}

export interface EventCountPerDevice {
  avgCountPerDevice?: number;
  previousAvgCountPerDevice?: number;
  countPerDevice?: DateTimeDecimalCounts[];
}

export interface EventCountPerSession {
  avgCountPerSession?: number;
  previousAvgCountPerSession?: number;
  countPerSession?: DateTimeDecimalCounts[];
}

/**
 * Event properties during the time range
*/
export interface EventProperties {
  eventProperties?: string[];
}

/**
 * An event property value with counts
*/
export interface EventPropertyValue {
  /**
   * The event property value name
  */
  name?: string;
  /**
   * The count of the the event property value
  */
  count?: number;
  /**
   * The count of previous time range of the event property value
  */
  previousCount?: number;
}

/**
 * Event property value counts during the time range in descending order
*/
export interface EventPropertyValues {
  /**
   * The total property value counts
  */
  total?: number;
  /**
   * The event property values
  */
  values?: EventPropertyValue[];
}

export interface Release {
  /**
   * Release Id.

  */
  release: string;
}

export interface ReleaseWithDistributionGroup extends Release {
  /**
   * Distribution group Id.

  */
  distributionGroup?: string;
}

export interface ReleaseWithDistributionGroupAndUserId extends ReleaseWithDistributionGroup {
  /**
   * Unique user Id.  Will generate a new user Id if not provided.

  */
  userId?: string;
}

export interface NotifyReleasesContainer {
  releases: ReleaseWithDistributionGroupAndUserId[];
}

export interface DeleteReleasesContainer {
  releases: Release[];
}

export interface GetReleasesContainer {
  releases: ReleaseWithDistributionGroup[];
}

export interface FilterReleasesContainer {
  releases?: Release[];
}

export interface FilterVersionsContainerVersionsItem {
  /**
   * App version

  */
  version: string;
  /**
   * App build number

  */
  build: string;
}

export interface FilterVersionsContainer {
  versions?: FilterVersionsContainerVersionsItem[];
}

export interface ReleaseCount {
  releaseId: string;
  /**
   * Distribution group queried.

  */
  distributionGroup?: string;
  /**
   * Count of unique downloads against user id.

  */
  uniqueCount: number;
  /**
   * Total count of downloads.

  */
  totalCount: number;
}

export interface ReleaseCounts {
  total?: number;
  counts: ReleaseCount[];
}

export interface DailySession {
  /**
   * the ISO 8601 datetime
  */
  datetime?: string;
  count?: number;
}

export interface ReleaseDailySessions {
  totalSessionCounts?: number;
  avgSessionsPerDay?: number;
  /**
   * Sessions per day
  */
  sessions?: DailySession[];
}

export interface DateTimeDownloadReleaseCount {
  /**
   * the ISO 8601 datetime
  */
  datetime?: string;
  total?: number;
  unique?: number;
}

export interface DateTimeDownloadReleaseCounts {
  total?: number;
  unique?: number;
  /**
   * Release Counts per day
  */
  counts?: DateTimeDownloadReleaseCount[];
}

/**
 * Device characteristics.
*/
export interface LogFlowDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

export interface LogFlowLog {
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  device: LogFlowDevice;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

export interface LogFlowLogContainer {
  /**
   * indicates if the number of available logs are more than the max allowed return limit(100).
  */
  exceededMaxLimit?: boolean;
  /**
   * the timestamp of the last log received. This value can be used as the start time parameter in
   * the consecutive API call.
  */
  lastReceivedLogTimestamp?: Date;
  /**
   * the list of logs
  */
  logs: LogFlowLog[];
}

/**
 * Generic log.
*/
export interface LogFlowGenericLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Session ID.

  */
  sessionId?: string;
  /**
   * Event ID.

  */
  eventId?: string;
  /**
   * Event name.

  */
  eventName?: string;
  /**
   * Message ID.

  */
  messageId?: string;
  /**
   * event specific properties.

  */
  properties?: { [propertyName: string]: string };
  device: LogFlowDevice;
}

export interface LogFlowGenericLogContainer {
  /**
   * indicates if the number of available logs are more than the max allowed return limit(100).
  */
  exceededMaxLimit?: boolean;
  /**
   * the timestamp of the last log received. This value can be used as the start time parameter in
   * the consecutive API call.
  */
  lastReceivedLogTimestamp?: Date;
  /**
   * the list of logs
  */
  logs: LogFlowGenericLog[];
}

export interface LogFlowLogWithProperties extends LogFlowLog {
  /**
   * Additional key/value pair parameters.

  */
  properties?: { [propertyName: string]: string };
}

/**
 * Required explicit begin session log (a marker event for analytics service).
*/
export interface LogFlowStartSessionLog extends LogFlowLog {
  /**
   * Session ID.

  */
  sessionId: string;
}

/**
 * Describe a AppCenter.Start API call from the SDK.
*/
export interface LogFlowStartServiceLog extends LogFlowLog {
  /**
   * The list of services of the AppCenter Start API call.
  */
  services?: string[];
}

export interface LogFlowCustomProperty {
  name: string;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Set or remove custom properties.
*/
export interface LogFlowCustomPropertyLog extends LogFlowLog {
  /**
   * Custom property changes.
  */
  properties?: LogFlowCustomProperty[];
}

/**
 * String property.
*/
export interface LogFlowStringProperty extends LogFlowCustomProperty {
  /**
   * String property value.
  */
  value: string;
}

/**
 * Number property.
*/
export interface LogFlowNumberProperty extends LogFlowCustomProperty {
  /**
   * Number property value.
  */
  value: number;
}

/**
 * Boolean property.
*/
export interface LogFlowBooleanProperty extends LogFlowCustomProperty {
  /**
   * Boolean property value.
  */
  value: boolean;
}

/**
 * Date and time property.
*/
export interface LogFlowDateTimeProperty extends LogFlowCustomProperty {
  /**
   * Date time property value.
  */
  value: Date;
}

/**
 * Clear an existing property.
*/
export interface LogFlowClearProperty extends LogFlowCustomProperty {
}

/**
 * Page view log (as in screens or activities).
*/
export interface LogFlowPageLog extends LogFlowLogWithProperties {
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Name of the page.

  */
  name: string;
}

/**
 * Event log.
*/
export interface LogFlowEventLog extends LogFlowLogWithProperties {
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Unique identifier for this event.

  */
  id: string;
  /**
   * Name of the event.

  */
  name: string;
}

/**
 * Push installation Information.
*/
export interface LogFlowPushInstallationLog extends LogFlowLog {
  /**
   * The PNS handle for this installation.

  */
  pushToken: string;
}

/**
 * Error log.
*/
export interface LogFlowErrorLog extends LogFlowLog {
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Error identifier.
  */
  id: string;
  /**
   * Corresponds to the number of milliseconds elapsed between the time the error occurred and the
   * app was launched.

  */
  appLaunchToffset?: number;
}

export interface ErrorGroupState {
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  state: string;
  annotation?: string;
}

export interface ErrorGroup extends ErrorGroupState {
  errorGroupId: string;
  appVersion: string;
  appBuild?: string;
  count: number;
  deviceCount: number;
  firstOccurrence: Date;
  lastOccurrence: Date;
  exceptionType?: string;
  exceptionMessage?: string;
  exceptionClassName?: string;
  exceptionClassMethod?: boolean;
  exceptionMethod?: string;
  exceptionAppCode?: boolean;
  exceptionFile?: string;
  exceptionLine?: string;
  codeRaw?: string;
  reasonFrames?: HandledErrorReasonFrame[];
}

export interface ErrorGroupListItem extends ErrorGroup {
}

export interface ErrorGroups {
  nextLink?: string;
  errorGroups?: ErrorGroupListItem[];
}

export interface ErrorGroupsSearchResult {
  hasMoreResults?: boolean;
  errorGroups?: ErrorGroupListItem[];
}

export interface ErrorDateTimeCounts {
  /**
   * the ISO 8601 datetime
  */
  datetime?: string;
  /**
   * count of the object
  */
  count?: number;
}

export interface ErrorCounts {
  /**
   * total error count
  */
  count?: number;
  /**
   * the total error count for day
  */
  errors?: ErrorDateTimeCounts[];
}

export interface HandledErrorReasonFrame {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface ErrorDateTimePercentages {
  /**
   * the ISO 8601 datetime
  */
  datetime?: string;
  /**
   * percentage of the object
  */
  percentage?: number;
}

export interface ErrorDownloadLink {
  link: string;
}

/**
 * a single frame of a stack trace
*/
export interface DiagnosticsStackFrame {
  /**
   * address of the frame
  */
  address?: string;
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Raw frame string
  */
  codeRaw: string;
  /**
   * Formatted frame string
  */
  codeFormatted: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * frame should be shown always
  */
  relevant?: boolean;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
}

/**
 * a exception
*/
export interface DiagnosticsException {
  /**
   * Reason of the exception
  */
  reason?: string;
  /**
   * Type of the exception (NSSomethingException, NullPointerException)
  */
  type?: string;
  /**
   * frames of the excetpion
  */
  frames: DiagnosticsStackFrame[];
  /**
   * relevant exception (crashed)
  */
  relevant?: boolean;
  innerExceptions?: DiagnosticsException[];
  /**
   * SDK/Platform this thread is beeing generated from. Possible values include: 'ios', 'android',
   * 'xamarin', 'react-native', 'ndk', 'unity', 'other'
  */
  platform?: string;
}

/**
 * a thread representation
*/
export interface DiagnosticsThread {
  /**
   * name of the thread
  */
  title: string;
  /**
   * frames of that thread
  */
  frames: DiagnosticsStackFrame[];
  /**
   * potential additional exception happened in that thread (Last Exception Backtrace)
  */
  exception?: DiagnosticsException;
  /**
   * Shows if a thread is relevant or not. Is false if all frames are non relevant, otherwise true
  */
  relevant?: boolean;
  /**
   * SDK/Platform this thread is beeing generated from. Possible values include: 'ios', 'android',
   * 'xamarin', 'react-native', 'ndk', 'unity', 'other'
  */
  platform?: string;
  /**
   * True if this thread crashed
  */
  crashed?: boolean;
}

/**
 * a stacktrace in a processed and prettyfied way
*/
export interface DiagnosticsStackTrace {
  title?: string;
  reason?: string;
  threads?: DiagnosticsThread[];
  exception?: DiagnosticsException;
}

export interface ErrorFreeDevicePercentages {
  /**
   * Average percentage
  */
  averagePercentage?: number;
  /**
   * The error-free percentage per day.
  */
  dailyPercentages?: ErrorDateTimePercentages[];
}

export interface HandledError {
  errorId?: string;
  timestamp?: Date;
  deviceName?: string;
  osVersion?: string;
  osType?: string;
  country?: string;
  language?: string;
  userId?: string;
}

export interface HandledErrors {
  nextLink?: string;
  /**
   * Errors list.
  */
  errors?: HandledError[];
}

export interface ErrorsSearchResult {
  hasMoreResults?: boolean;
  errors?: HandledError[];
}

export interface HandledErrorDetails extends HandledError {
  name?: string;
  reasonFrames?: HandledErrorReasonFrame[];
  /**
   * Timestamp when the app was launched, example: '2017-03-13T18:05:42Z'.

  */
  appLaunchTimestamp?: Date;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Flag indicating if device is jailbroken

  */
  jailbreak?: boolean;
  properties?: { [propertyName: string]: string };
}

export interface ErrorDeleteCounter {
  appId?: string;
  errorGroupId?: string;
  errorId?: string;
  errorsDeleted?: number;
  attachmentsDeleted?: number;
  blobsSucceeded?: number;
  blobsFailed?: number;
}

export interface ErrorLocation {
  uri?: string;
}

export interface ErrorAttachment {
  appId?: string;
  attachmentId?: string;
  crashId?: string;
  blobLocation?: string;
  contentType?: string;
  fileName?: string;
  createdTime?: Date;
  size?: number;
}

export interface ErrorAttachmentText {
  content?: string;
}

export interface ErrorAttachmentLocation {
  uri?: string;
}

export interface ErrorGroupModel {
  /**
   * model name
  */
  modelName?: string;
  /**
   * model code
  */
  modelCode?: string;
  /**
   * count of errors in a model
  */
  errorCount?: number;
}

export interface ErrorGroupModels {
  errorCount?: number;
  modelsProperty?: ErrorGroupModel[];
}

export interface ErrorGroupOperatingSystem {
  /**
   * OS name
  */
  operatingSystemName?: string;
  /**
   * count of OS
  */
  errorCount?: number;
}

export interface ErrorGroupOperatingSystems {
  errorCount?: number;
  operatingSystems?: ErrorGroupOperatingSystem[];
}

/**
 * Device characteristics.
*/
export interface DeviceDiagnostics {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Generic log.
*/
export interface GenericLogDiagnostics {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Session ID.

  */
  sessionId?: string;
  /**
   * Event ID.

  */
  eventId?: string;
  /**
   * Event name.

  */
  eventName?: string;
  /**
   * Message ID.

  */
  messageId?: string;
  /**
   * event specific properties.

  */
  properties?: { [propertyName: string]: string };
  device: DeviceDiagnostics;
}

export interface GenericLogContainerDiagnostics {
  /**
   * indicates if the number of available logs are more than the max allowed return limit(100).
  */
  exceededMaxLimit?: boolean;
  /**
   * the timestamp of the last log received. This value can be used as the start time parameter in
   * the consecutive API call.
  */
  lastReceivedLogTimestamp?: Date;
  /**
   * the list of logs
  */
  logs: GenericLogDiagnostics[];
}

export interface LogDiagnostics {
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  device: DeviceDiagnostics;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

export interface LogWithPropertiesDiagnostics extends LogDiagnostics {
  /**
   * Additional key/value pair parameters.

  */
  properties?: { [propertyName: string]: string };
}

/**
 * Required explicit begin session log (a marker event for analytics service).
*/
export interface StartSessionLogDiagnostics extends LogDiagnostics {
  /**
   * Session ID.

  */
  sessionId: string;
}

/**
 * Required explicit begin session log (a marker event for analytics service).
*/
export interface HanledErrorLogDiagnostics extends LogDiagnostics {
  /**
   * Error ID.

  */
  errorId: string;
}

/**
 * Describe a AppCenter.Start API call from the SDK.
*/
export interface StartServiceLogDiagnostics extends LogDiagnostics {
  /**
   * The list of services of the AppCenter Start API call.
  */
  services?: string[];
}

export interface CustomPropertyDiagnostics {
  name: string;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Set or remove custom properties.
*/
export interface CustomPropertyLogDiagnostics extends LogDiagnostics {
  /**
   * Custom property changes.
  */
  properties?: CustomPropertyDiagnostics[];
}

/**
 * String property.
*/
export interface StringPropertyDiagnostics extends CustomPropertyDiagnostics {
  /**
   * String property value.
  */
  value: string;
}

/**
 * Number property.
*/
export interface NumberPropertyDiagnostics extends CustomPropertyDiagnostics {
  /**
   * Number property value.
  */
  value: number;
}

/**
 * Boolean property.
*/
export interface BooleanPropertyDiagnostics extends CustomPropertyDiagnostics {
  /**
   * Boolean property value.
  */
  value: boolean;
}

/**
 * Date and time property.
*/
export interface DateTimePropertyDiagnostics extends CustomPropertyDiagnostics {
  /**
   * Date time property value.
  */
  value: Date;
}

/**
 * Clear an existing property.
*/
export interface ClearPropertyDiagnostics extends CustomPropertyDiagnostics {
}

/**
 * Page view log (as in screens or activities).
*/
export interface PageLogDiagnostics extends LogWithPropertiesDiagnostics {
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Name of the page.

  */
  name: string;
}

/**
 * Event log.
*/
export interface EventLogDiagnostics extends LogWithPropertiesDiagnostics {
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Unique identifier for this event.

  */
  id: string;
  /**
   * Name of the event.

  */
  name: string;
}

/**
 * Push installation Information.
*/
export interface PushInstallationLogDiagnostics extends LogDiagnostics {
  /**
   * The PNS handle for this installation.

  */
  pushToken: string;
}

/**
 * Error log.
*/
export interface ErrorLogDiagnostics extends LogDiagnostics {
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Error identifier.
  */
  id: string;
  /**
   * Corresponds to the number of milliseconds elapsed between the time the error occurred and the
   * app was launched.

  */
  appLaunchToffset?: number;
}

export interface VersionDiagnostics {
  /**
   * version
  */
  version?: string;
  /**
   * version count
  */
  count?: number;
  /**
   * the count of previous time range of the version
  */
  previousCount?: number;
}

export interface VersionsDiagnostics {
  /**
   * list of version count
  */
  versions?: VersionDiagnostics[];
  /**
   * the total count of versions
  */
  total?: number;
}

export interface AvailableVersionsDiagnostics {
  /**
   * List of available versions.
  */
  versions?: string[];
  /**
   * The full number of versions across all pages.
  */
  totalCount?: number;
}

export interface ErrorRetentionSettings {
  retentionInDays: number;
}

/**
 * Export configuration
*/
export interface ExportConfiguration {
  exportEntities?: string[];
  /**
   * The resource name on azure
  */
  resourceName?: string;
  /**
   * The resource group name on azure
  */
  resourceGroup?: string;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Configuration for export to Blob Storage with blob format
*/
export interface ExportBlobConfiguration extends ExportConfiguration {
  /**
   * The path to the blob when enum set to 'WithoutAppId' is 'year/month/day/hour/minute' and when
   * set to 'WithAppId' is 'appId/year/month/day/hour/minute'. Possible values include:
   * 'WithoutAppId', 'WithAppId'
  */
  blobPathFormatKind?: string;
}

/**
 * Configuration for export to Blob Storage with customer provided connection string
*/
export interface ExportConfigurationBlobStorageConnectionString extends ExportBlobConfiguration {
  /**
   * Connection string for blob storage account
  */
  connectionString: string;
}

/**
 * Configuration for export to Application Insights resource with customer provided intrumentation
 * key
*/
export interface ExportConfigurationAppInsightsKey extends ExportConfiguration {
  /**
   * Instrumentation key for Application Insights resource
  */
  instrumentationKey: string;
}

/**
 * Configuration for export to Blob Storage with customer linked subscription.
*/
export interface ExportConfigurationBlobStorageLinkedSubscription extends ExportBlobConfiguration {
  /**
   * Id of customer subscription linked in App Center
  */
  subscriptionId: string;
}

/**
 * Configuration for export to Application Insights resource with customer linked subscription.
*/
export interface ExportConfigurationAppInsightsLinkedSubscription extends ExportConfiguration {
  /**
   * Id of customer subscription linked in App Center
  */
  subscriptionId: string;
}

/**
 * Export configuration result
*/
export interface ExportConfigurationResult {
  /**
   * Export configuration id
  */
  id: string;
  /**
   * Target resource type of export configuration. Possible values include: 'BlobStorage',
   * 'AppInsights'
  */
  exportType: string;
  /**
   * Creation time in ISO 8601 format
  */
  creationTime: string;
  /**
   * Latest time in ISO 8601 format when export completed successfully
  */
  lastRunTime?: string;
  exportEntities?: string[];
  /**
   * State of the export job. Possible values include: 'Enabled', 'Disabled', 'Pending', 'Deleted',
   * 'Invalid'
  */
  state: string;
  /**
   * Additional information about export configuration state
  */
  stateInfo?: string;
  /**
   * resource group for the storage account/App Insights resource
  */
  resourceGroup?: string;
  /**
   * Storage accout or Appinsights resource name
  */
  resourceName?: string;
  exportConfiguration?: ExportConfiguration;
}

/**
 * List of export configurations
*/
export interface ExportConfigurationListResult {
  values: ExportConfigurationResult[];
  /**
   * the total count of exports
  */
  total?: number;
  nextLink?: string;
}

/**
 * Type of Notification target (audiences, devices, user ids or account ids). The object must
 * include the correct properties for the specified target type.
*/
export interface NotificationTarget {
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Notification statistics
*/
export interface NotificationOverviewResult {
  /**
   * Notification id.
  */
  notificationId: string;
  /**
   * Notification name
  */
  name?: string;
  notificationTarget?: NotificationTarget;
  /**
   * Notification send time
  */
  sendTime?: Date;
  /**
   * Number of the notifications failed to send to the push provider.
  */
  pnsSendFailure?: number;
  /**
   * Number of the notifications successfully sent to push the provider.
  */
  pnsSendSuccess?: number;
  /**
   * State of the notification. Possible values include: 'Queued', 'Sending', 'Completed',
   * 'Failed', 'NoTargetFound'
  */
  state: string;
}

/**
 * List of notifications
*/
export interface NotificationsListResult {
  values: NotificationOverviewResult[];
  /**
   * the total count of notifications
  */
  total?: number;
  nextLink?: string;
}

/**
 * Notification definition object
*/
export interface NotificationContent {
  /**
   * Notification name
  */
  name: string;
  /**
   * Notification title
  */
  title?: string;
  /**
   * Notification body
  */
  body: string;
  /**
   * Notification custom data (such as badge, color, sound, etc.)
  */
  customData?: { [propertyName: string]: string };
}

/**
 * Notification failure outcome count
*/
export interface NotificationFailureOutcomeCount {
  /**
   * The reason of the notification failure
  */
  failureReason?: string;
  /**
   * count of this type of failure
  */
  count?: number;
}

/**
 * Notification statistics
*/
export interface NotificationDetailsResult extends NotificationOverviewResult {
  notificationContent: NotificationContent;
  /**
   * Failture outcome counts
  */
  failureOutcomes?: NotificationFailureOutcomeCount[];
}

/**
 * List of notification Ids
*/
export interface NotificationIdList {
  /**
   * List of notification Ids.
  */
  values: string[];
}

/**
 * Notification definition object
*/
export interface NotificationDefinition {
  notificationTarget?: NotificationTarget;
  notificationContent: NotificationContent;
}

/**
 * Notification send succeeded.
*/
export interface NotificationSendSucceededResult {
  /**
   * The unique notification identifier.
  */
  notificationId: string;
}

/**
 * Notification per User IDs
*/
export interface NotificationTargetUserIds extends NotificationTarget {
  /**
   * List of user IDs to target
  */
  userIds: string[];
}

/**
 * Notification per Account IDs
*/
export interface NotificationTargetAccountIds extends NotificationTarget {
  /**
   * List of account IDs to target
  */
  accountIds: string[];
}

/**
 * Notification target audiences.
*/
export interface NotificationTargetAudiences extends NotificationTarget {
  /**
   * List of target audiences.
  */
  audiences: string[];
}

/**
 * Notification target devices. If null, all devices will be targeted(broadcast).
*/
export interface NotificationTargetDevices extends NotificationTarget {
  /**
   * List of target devices.
  */
  devices: string[];
}

/**
 * Generic notification configuration. Is a base type and caller should choose one of the derived
 * types specified in the enum.
*/
export interface NotificationConfig {
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Apple notification certificate configuration.
*/
export interface NotificationConfigApple extends NotificationConfig {
  /**
   * Possible values include: 'production', 'sandbox'
  */
  endpointType: string;
  /**
   * Base64 encoded certificate string.
  */
  certEncoded: string;
  /**
   * Certificate file name
  */
  certFilename: string;
  /**
   * Certificate password
  */
  certKey: string;
}

/**
 * Apple notification auth token configuration.
*/
export interface NotificationConfigAppleToken extends NotificationConfig {
  /**
   * A 10-character key identifier (kid).
  */
  keyId: string;
  /**
   * Application ID.
  */
  id: string;
  /**
   * Application prefix.
  */
  prefix: string;
  /**
   * Provider Authentication Token.
  */
  token: string;
  /**
   * Possible values include: 'production', 'sandbox'
  */
  endpointType: string;
}

/**
 * Google notification configuration.
*/
export interface NotificationConfigGoogle extends NotificationConfig {
  /**
   * GCM API key.
  */
  googleApiKey: string;
}

/**
 * WNS notification configuration.
*/
export interface NotificationConfigWindows extends NotificationConfig {
  /**
   * Package security identifier (SID).
  */
  packageSid: string;
  /**
   * Secret key.
  */
  secretKey: string;
}

/**
 * Generic notification configuration result.
*/
export interface NotificationConfigResult {
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Apple notification certificate configuration result.
*/
export interface NotificationConfigAppleResult extends NotificationConfigResult {
  /**
   * Possible values include: 'production', 'sandbox'
  */
  endpointType: string;
  /**
   * Certificate expiration date.
  */
  certExpiration: Date;
  /**
   * Certificate file name
  */
  certFilename: string;
}

/**
 * Apple notification auth token configuration result.
*/
export interface NotificationConfigAppleTokenResult extends NotificationConfigResult {
  /**
   * A 10-character key identifier (kid).
  */
  keyId: string;
  /**
   * Application ID.
  */
  id: string;
  /**
   * Application Prefix.
  */
  prefix: string;
  /**
   * Possible values include: 'production', 'sandbox'
  */
  endpointType: string;
}

/**
 * Google notification configuration result.
*/
export interface NotificationConfigGoogleResult extends NotificationConfigResult {
  /**
   * GCM API key.
  */
  googleApiKey: string;
}

/**
 * WNS notification configuration result.
*/
export interface NotificationConfigWindowsResult extends NotificationConfigResult {
  /**
   * Package security identifier (SID).
  */
  packageSid: string;
  /**
   * windows push configuration secret key.
  */
  secretKey?: string;
}

/**
 * Generic export configuration.
*/
export interface ExportConfig {
  /**
   * A shared access signature (SAS) URI with Read, Write and Delete permissions on a container.
  */
  blobContainerSasUri: string;
}

/**
 * Export started.
*/
export interface ExportStartedResult {
  /**
   * The unique export identifier.
  */
  exportId: string;
}

/**
 * Export status
*/
export interface ExportStatusResult {
  /**
   * The unique export identifier.
  */
  exportId: string;
  /**
   * Status of the export. Possible values include: 'InProgress', 'Completed', 'Failed'
  */
  status: string;
}

export interface AppId {
  /**
   * the id of the app
  */
  id?: string;
}

export interface DeviceConfigurationImage {
  full?: string;
  thumb?: string;
}

/**
 * Physical device dimensions
*/
export interface DeviceDimensions {
  depth?: any;
  height?: any;
  width?: any;
}

/**
 * Device screen resolution
*/
export interface DeviceResolution {
  height?: string;
  width?: string;
  ppi?: string;
}

/**
 * Physical device screen dimensions
*/
export interface DeviceScreenSize {
  cm?: string;
  inProperty?: string;
}

/**
 * CPU data for device
*/
export interface DeviceCpu {
  frequency?: string;
  core?: string;
  text?: string;
}

/**
 * Memory data for device
*/
export interface DeviceMemory {
  formattedSize?: string;
}

export interface DeviceFrameDefinition {
  width?: number;
  height?: number;
  frameUrl?: string;
  screen?: number[];
}

export interface DeviceFrame {
  grid?: DeviceFrameDefinition;
  full?: DeviceFrameDefinition;
}

export interface DeviceModel {
  name?: string;
  manufacturer?: string;
  model?: string;
  platform?: string;
  dimensions?: DeviceDimensions;
  resolution?: DeviceResolution;
  releaseDate?: string;
  formFactor?: string;
  screenSize?: DeviceScreenSize;
  cpu?: DeviceCpu;
  memory?: DeviceMemory;
  screenRotation?: number;
  deviceFrame?: DeviceFrame;
  availabilityCount?: number;
}

export interface DeviceConfiguration {
  /**
   * The name of the device model and OS version
  */
  name?: string;
  /**
   * The unique id of the device configuration
  */
  id?: string;
  /**
   * The tier
  */
  tier?: number;
  image?: DeviceConfigurationImage;
  model?: DeviceModel;
  os?: string;
  osName?: string;
  marketShare?: number;
}

export interface DeviceSetConfigurationImage {
  thumb?: string;
}

export interface DeviceSetModel {
  name?: string;
  manufacturer?: string;
  releaseDate?: string;
  formFactor?: string;
}

export interface DeviceSetConfiguration {
  /**
   * The unique id of the device configuration
  */
  id?: string;
  image?: DeviceSetConfigurationImage;
  model?: DeviceSetModel;
  os?: string;
  osName?: string;
}

/**
 * @summary Test Run Statistics
 * @description Summary single test run on Xamarin Test Cloud
*/
export interface TestRunStatistics {
  /**
   * Number of devices running the test
  */
  devices?: number;
  /**
   * Number of finished devices
  */
  devicesFinished?: number;
  /**
   * Number of failed devices
  */
  devicesFailed?: number;
  /**
   * Number of tests in total
  */
  total?: number;
  /**
   * Number of passed tests
  */
  passed?: number;
  /**
   * Number of failed tests
  */
  failed?: number;
  /**
   * Number of skipped tests
  */
  skipped?: number;
  /**
   * The max amount of MB used during the test run
  */
  peakMemory?: number;
  /**
   * The number of minutes of device time the test has been runnign
  */
  totalDeviceMinutes?: number;
}

/**
 * @summary Test Run
 * @description Summary single test run on Xamarin Test Cloud
*/
export interface TestRun {
  /**
   * The unique id of the test upload
  */
  id?: string;
  /**
   * The date and time the test was uploaded
  */
  date?: string;
  /**
   * The compiled version of the app binary
  */
  appVersion?: string;
  /**
   * The name of the test series with which this test upload is associated
  */
  testSeries?: string;
  /**
   * The device platform targeted by the test. Possible values are 'ios' or 'android'
  */
  platform?: string;
  /**
   * The current status of the test run, in relation to the various phases
  */
  runStatus?: string;
  /**
   * The passed/failed state
  */
  resultStatus?: string;
  /**
   * Deprecated. Use runStatus instead.
  */
  state?: string;
  /**
   * Deprecated. Use resultStatus instead.
  */
  status?: string;
  /**
   * Human readable explanation of the current test status
  */
  description?: string;
  stats?: TestRunStatistics;
  /**
   * The name of the test framework used to run this test
  */
  testType?: string;
}

/**
 * @summary Test Run Summary
 * @description Most important information about a test run.
*/
export interface TestRunSummary {
  /**
   * Date of the test run.
  */
  date?: string;
  /**
   * Human-readable status of the test run.
  */
  statusDescription?: string;
  /**
   * Number of failed tests
  */
  failed?: number;
  /**
   * Number of passed tests
  */
  passed?: number;
  /**
   * Tells whether the test run has completed
  */
  completed?: boolean;
}

/**
 * @summary Test Series
 * @description Summary of a single test series
*/
export interface TestSeries {
  /**
   * Unique, human-readable identifier of the test series
  */
  slug: string;
  /**
   * Name of the test series
  */
  name: string;
  /**
   * Date of the latest test run that used this test series
  */
  mostRecentActivity?: string;
  /**
   * Most recent test runs
  */
  testRuns?: TestRunSummary[];
}

/**
 * @summary Name of the test series
*/
export interface TestSeriesName {
  /**
   * Name of the new test series
  */
  name: string;
}

/**
 * @summary Device List
 * @description A list of device IDs
*/
export interface DeviceList {
  devices: string[];
}

/**
 * @summary Device Selection
 * @description Short ID for a list of device IDs
*/
export interface DeviceSelection {
  /**
   * Identifier of the device selection
  */
  shortId: string;
}

/**
 * @summary Device Set update information
 * @description The name of the device set and the list of device IDs
*/
export interface DeviceSetUpdate {
  /**
   * List of device IDs
  */
  devices: string[];
  /**
   * The name of the device set
  */
  name: string;
}

/**
 * @summary Device Set Owner
 * @description The owner of a device set
*/
export interface DeviceSetOwner {
  /**
   * Type of account
  */
  type: string;
  /**
   * Account ID
  */
  id: string;
  /**
   * Display name of the account
  */
  displayName?: string;
  /**
   * Name of the account
  */
  name: string;
}

/**
 * @summary Device Set
 * @description The name and devices of the device set
*/
export interface DeviceSet {
  /**
   * Identifier of the device set
  */
  id: string;
  /**
   * The number of manufacturers in the device set's device selection
  */
  manufacturerCount?: number;
  /**
   * Name of the device set
  */
  name: string;
  /**
   * Slug of the device set
  */
  slug?: string;
  owner: DeviceSetOwner;
  /**
   * The number of os versions in the device set's device selection
  */
  osVersionCount?: number;
  deviceConfigurations: DeviceSetConfiguration[];
}

/**
 * @summary Subscription Tier
*/
export interface Tier {
  /**
   * The name of the tier
  */
  name?: string;
}

/**
 * @summary Subscription
 * @description Subscription information
*/
export interface Subscription {
  /**
   * The date the subscription began
  */
  startsAt?: string;
  /**
   * The date the subscription will end or ended
  */
  endsAt?: string;
  /**
   * The number of days left in the subscription
  */
  daysLeft?: number;
  tier?: Tier;
  /**
   * Is the subscription currently active?
  */
  active?: boolean;
  /**
   * Id of the subscription
  */
  id?: string;
}

export interface TestReportStats {
  os: number;
  devices: number;
  filesize: number;
  totalDeviceMinutes: number;
  devicesNotRunned: number;
  failed: number;
  skipped: number;
  passed: number;
  total: number;
  devicesFinished: number;
  devicesFailed: number;
  devicesSkipped: number;
  stepCount: number;
  artifacts?: { [propertyName: string]: string };
}

export interface TestReportFeaturesItemTestsItemRunsItemStepsItemStepExecutionsItem {
  deviceSnapshotId?: string;
  status?: string;
  timestamp?: number;
}

export interface TestReportFeaturesItemTestsItemRunsItemStepsItem {
  stepName?: string;
  id?: string;
  stepExecutions?: TestReportFeaturesItemTestsItemRunsItemStepsItemStepExecutionsItem[];
  failed?: number;
  skipped?: number;
  stepReportUrl?: string;
}

export interface TestReportFeaturesItemTestsItemRunsItem {
  number?: number;
  steps?: TestReportFeaturesItemTestsItemRunsItemStepsItem[];
  failed?: number;
  skipped?: number;
  reportUrl?: string;
  id?: string;
}

export interface TestReportFeaturesItemTestsItem {
  testName?: string;
  runs?: TestReportFeaturesItemTestsItemRunsItem[];
  peakMemory?: number;
  peakDuration?: number;
}

export interface TestReportFeaturesItem {
  name?: string;
  tests?: TestReportFeaturesItemTestsItem[];
  failed?: number;
  skipped?: number;
  peakMemory?: number;
  peakDuration?: number;
}

export interface TestReportDeviceLogsItem {
  deviceSnapshotId?: string;
  deviceLog?: string;
  testLog?: string;
  appiumLog?: string;
}

export interface TestReportSnapshotFatalErrorsItem {
  deviceSnapshotId?: string;
  errorMessage?: string;
  errorTitle?: string;
}

export interface TestReport {
  appUploadId: string;
  date: string;
  testType: string;
  platform: string;
  stats: TestReportStats;
  id: string;
  schemaVersion: number;
  revision: number;
  features: TestReportFeaturesItem[];
  finishedDeviceSnapshots: string[];
  deviceLogs: TestReportDeviceLogsItem[];
  dateFinished: string;
  errorMessage?: string;
  snapshotFatalErrors?: TestReportSnapshotFatalErrorsItem[];
}

export interface StepReportDeviceScreenshotsItemScreenshotUrls {
  original: string;
  small: string;
  medium: string;
  large: string;
}

export interface StepReportDeviceScreenshotsItemScreenshot {
  urls: StepReportDeviceScreenshotsItemScreenshotUrls;
  rotation: number;
  landscape: boolean;
}

export interface StepReportDeviceScreenshotsItem {
  id?: string;
  deviceSnapshotId?: string;
  stacktrace?: string[];
  crashData?: string[];
  status?: string;
  title?: string;
  screenshot?: StepReportDeviceScreenshotsItemScreenshot;
  logFile?: string;
  appiumLogFile?: string;
  rawCrashData?: string[];
}

export interface StepReport {
  finishedSnapshots: string[];
  deviceScreenshots: StepReportDeviceScreenshotsItem[];
}

/**
 * @summary Test Cloud Error Details
 * @description Details of a failed operation
*/
export interface TestCloudErrorDetails {
  /**
   * Status of the operation
  */
  status: string;
  /**
   * Human-readable message that describes the error
  */
  message: string;
}

/**
 * @summary Test Cloud File Hash
 * @description Hash, type, path and byte range of a file that is required in test run
*/
export interface TestCloudFileHashDeprecated {
  /**
   * Type of the file. Possible values include: 'dsym-file', 'app-file', 'test-file'
  */
  fileType: string;
  /**
   * SHA256 hash of the file
  */
  checksum: string;
  /**
   * Relative path of the file
  */
  relativePath: string;
  /**
   * Range of bytes required to verify ownership of the file
  */
  byteRange?: string;
}

/**
 * @summary Test Cloud File Hash
 * @description Hash, type, path and byte range of a file that is required in test run
*/
export interface TestCloudFileHash {
  /**
   * Type of the file. Possible values include: 'dsym-file', 'app-file', 'test-file'
  */
  fileType: string;
  /**
   * SHA256 hash of the file
  */
  checksum: string;
  /**
   * Relative path of the file
  */
  relativePath: string;
}

/**
 * @summary Test Cloud Hash Upload Status
 * @description Result of uploading a single file hash
*/
export interface TestCloudHashUploadStatus {
  /**
   * HTTP status code that represent result of upload
  */
  statusCode: number;
  /**
   * URI that should be used to make POST request if file with given hash doesn't exist. This is
   * set when status_code is equal to 412
  */
  location?: string;
}

/**
 * @summary Test Cloud File Hash Response
 * @description Response message for single uploaded file hash
*/
export interface TestCloudFileHashResponse {
  /**
   * Type of the file. Possible values include: 'dsym-file', 'app-file', 'test-file'
  */
  fileType: string;
  /**
   * SHA256 hash of the file
  */
  checksum: string;
  /**
   * Relative path of the file
  */
  relativePath?: string;
  /**
   * Status of the upload
  */
  uploadStatus: TestCloudHashUploadStatus;
}

/**
 * @summary Test Cloud Start Test Run Options
 * @description Options required to start the test run
*/
export interface TestCloudStartTestRunOptions {
  /**
   * Test framework used by tests.
  */
  testFramework: string;
  /**
   * Device selection string.
  */
  deviceSelection: string;
  /**
   * Language that should be used to run tests.
  */
  language?: string;
  /**
   * Locale that should be used to run tests.
  */
  locale?: string;
  /**
   * Name of the test series.
  */
  testSeries?: string;
  /**
   * A JSON dictionary with additional test parameters
  */
  testParameters?: any;
}

/**
 * @summary Test Cloud Test Run Start Result
 * @description Result of starting a test run
*/
export interface TestCloudStartTestRunResult {
  /**
   * List with names of accepted devices
  */
  acceptedDevices?: string[];
  /**
   * List with names and descriptions of rejected devices
  */
  rejectedDevices?: string[];
}

/**
 * @summary Test Run State
 * @description Current status of a test run
*/
export interface TestRunState {
  /**
   * Multi-line message that describes the status
  */
  message?: string[];
  /**
   * Time (in seconds) that the client should wait for before checking the status again
  */
  waitTime?: number;
  /**
   * The exit code that the client should use when exiting. Used for indicating status to the
   * caller of the client.
   * 0: test run completes with no failing tests
   * 1: test run completes with at least one failing test
   * 2: test run failed to complete. Status for test run is unknown

  */
  exitCode?: number;
}

export interface PerformanceReportPerformanceDataStepsItemSamplesItem {
  cpu?: number;
  mem?: number;
  elapsedSecs?: number;
}

export interface PerformanceReportPerformanceDataStepsItem {
  avgCpu?: number;
  avgMem?: number;
  samples?: PerformanceReportPerformanceDataStepsItemSamplesItem[];
  elapsedSecsEnd?: number;
  elapsedSecsStart?: number;
  elapsedSecs?: number;
  name?: string;
  id?: string;
}

export interface PerformanceReportPerformanceData {
  steps: PerformanceReportPerformanceDataStepsItem[];
  elapsedSecsEnd: number;
  elapsedSecsStart: number;
  elapsedSecs: number;
  id: string;
}

export interface PerformanceReportVideoVideoMetadataEventsItem {
  id?: string;
  millis?: number;
  name?: string;
  type?: string;
}

export interface PerformanceReportVideoVideoMetadata {
  events?: PerformanceReportVideoVideoMetadataEventsItem[];
}

export interface PerformanceReportVideo {
  videoMetadata: PerformanceReportVideoVideoMetadata;
  videoUrl: string;
}

/**
 * @summary Performance Report
 * @description Report data for a single test (a.k.a. scenario)
*/
export interface PerformanceReport {
  deviceSnapshotId?: string;
  performanceData?: PerformanceReportPerformanceData;
  video?: PerformanceReportVideo;
}

export interface SubmitDsrOperationRequest {
  /**
   * Possible values include: 'Delete', 'Purge', 'UndoDelete', 'Export'
  */
  request?: string;
  accountId?: string;
  appId?: string;
  /**
   * The DSR operation ID provided by the GDPR coordinator. Used for tracking only.
  */
  operationId?: string;
  /**
   * Request ID provided by the GDPR coordinator. Used for tracking.
  */
  requestId?: string;
}

export interface SubmitDsrOperationResponse {
  /**
   * The status of the DSR operation. Possible values include: 'NotStarted', 'InProgress',
   * 'Completed', 'Failure'
  */
  status?: string;
}

export interface CreateGdprTestData {
  appId?: string;
  accountId?: string;
  userName?: string;
  userEmail?: string;
  appName?: string;
}

export interface TestGDPRUser {
  id?: string;
}

export interface TestGDPRAccount {
  id?: string;
}

export interface TestGDPRFeatureFlag {
  name?: string;
  targetId?: string;
}

export interface TestGDPRResourceListResourcesItem {
  rel?: string;
  path?: string;
}

export interface TestGDPRResourceList {
  resources?: TestGDPRResourceListResourcesItem[];
}

export interface TestGDPRHashFile {
  id?: string;
  filename?: string;
}

export interface TestGDPRTestRun {
  id?: string;
  appHashFileId?: string;
  locale?: string;
  dsymHashFileId?: string;
  appHashFileUrl?: string;
  dsymHashFileUrl?: string;
  appIconUrl?: string;
}

export interface TestGDPRPipelineTest {
  appUploadId?: string;
  testParameters?: any;
}

export interface TestGDPRFileSetFile {
  path?: string;
  hashFileId?: string;
  appUploadId?: string;
  hashFileUrl?: string;
}

export interface CodePushReleaseUpload {
  /**
   * The ID for the newly created upload. It is going to be required later in the process.
  */
  id: string;
  /**
   * The URL domain used to upload the release.
  */
  uploadDomain: string;
  /**
   * The URL encoded token used for upload permissions.
  */
  token: string;
}

export interface CodePushUploadedRelease {
  /**
   * The upload metadata from the release initialization step.
  */
  releaseUpload: CodePushReleaseUpload;
  /**
   * the binary version of the application
  */
  targetBinaryVersion: string;
  /**
   * This specifies which deployment you want to release the update to. Default is Staging.
  */
  deploymentName?: string;
  /**
   * This provides an optional "change log" for the deployment.
  */
  description?: string;
  /**
   * This specifies whether an update should be downloadable by end users or not.
  */
  disabled?: boolean;
  /**
   * This specifies whether the update should be considered mandatory or not (e.g. it includes a
   * critical security fix).
  */
  mandatory?: boolean;
  /**
   * This specifies that if the update is identical to the latest release on the deployment, the
   * CLI should generate a warning instead of an error.
  */
  noDuplicateReleaseError?: boolean;
  /**
   * This specifies the percentage of users (as an integer between 1 and 100) that should be
   * eligible to receive this update.
  */
  rollout?: number;
}

export interface BlobInfo {
  size: number;
  url: string;
}

export interface CodePushReleaseInfo {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
}

export interface CodePushRelease extends CodePushReleaseInfo {
  label?: string;
  packageHash?: string;
  blobUrl?: string;
  diffPackageMap?: { [propertyName: string]: BlobInfo };
  /**
   * Set on 'Promote'
  */
  originalDeployment?: string;
  /**
   * Set on 'Promote' and 'Rollback'
  */
  originalLabel?: string;
  releasedBy?: string;
  /**
   * The release method is unknown if unspecified. Possible values include: 'Upload', 'Promote',
   * 'Rollback'
  */
  releaseMethod?: string;
  size?: number;
  uploadTime?: number;
}

export interface Deployment {
  key?: string;
  name: string;
  latestRelease?: CodePushRelease;
}

export interface DeploymentInternal extends Deployment {
  id?: string;
}

export interface DeploymentModification {
  name: string;
}

export interface CodePushReleaseLabel {
  label?: string;
}

export interface CodePushReleaseModification extends CodePushReleaseInfo {
}

export interface CodePushReleasePromote extends CodePushReleaseInfo {
  label?: string;
}

export interface CodePushReleaseMetric {
  label: string;
  active: number;
  downloaded?: number;
  failed?: number;
  installed?: number;
}

export interface CodePushStatusMetricMetadata {
  deploymentKey: string;
  label?: string;
  appVersion?: string;
  previousDeploymentKey?: string;
  previousLabelOrAppVersion?: string;
  status?: string;
  clientUniqueId?: string;
}

export interface UpdateCheckResponse extends CodePushReleaseInfo {
  downloadUrl?: string;
  isAvailable: boolean;
  packageSize?: number;
  shouldRunBinaryVersion?: boolean;
  updateAppVersion?: boolean;
  packageHash?: string;
  label?: string;
}

export interface AcquisitionStatusSuccessResponse {
  /**
   * The code indicating the status
  */
  code: string;
  /**
   * The message indicating the status
  */
  message: string;
}

export interface GDPRPurgeVerifyRequest {
  /**
   * deployment id
  */
  id: string;
  /**
   * deployment key
  */
  key: string;
}

export interface GDPRPurgeVerifyResponse {
  /**
   * indicate whether GDPR purge operation succeeds or not
  */
  success: boolean;
}

/**
 * Generic result for any alerting API operation
*/
export interface AlertOperationResult {
  /**
   * Unique request identifier for tracking
  */
  requestId: string;
}

/**
 * Alerting webhook
*/
export interface AlertWebhook {
  /**
   * The unique id (UUID) of the webhook
  */
  id?: string;
  /**
   * display name of the webhook
  */
  name: string;
  /**
   * target url of the webhook
  */
  url: string;
  /**
   * Allows eanble/disable webhook
  */
  enabled?: boolean;
  /**
   * Event types enabled for webhook
  */
  eventTypes: string[];
}

/**
 * List of alerting webhooks wrapped as operation result
*/
export interface AlertWebhookListResult {
  values: AlertWebhook[];
}

/**
 * Alerting webhook ping operation result
*/
export interface AlertWebhookPingResult extends AlertOperationResult {
  /**
   * HTTP status code returned in response from calling webhook
  */
  responseStatusCode: number;
  /**
   * Reason returned in response from calling webhook
  */
  responseReason?: string;
}

/**
 * Event Setting
*/
export interface EventSetting {
  /**
   * Frequency of event. Possible values include: 'Disabled', 'Individual', 'Daily',
   * 'DailyAndIndividual', 'Default'
  */
  value: string;
  /**
   * Default frequency of event. Possible values include: 'Disabled', 'Individual', 'Daily',
   * 'DailyAndIndividual'
  */
  defaultValue?: string;
}

/**
 * Alerting Email Settings
*/
export interface AlertEmailSettings {
  /**
   * The settings the user has for the app
  */
  settings: EventSetting[];
}

/**
 * Alerting Default Email Settings of the user
*/
export interface AlertUserEmailSettingsResult extends AlertOperationResult {
  /**
   * The ETag of the entity
  */
  eTag?: string;
  /**
   * Allows to forcefully disable emails on app or user level
  */
  enabled: boolean;
  /**
   * The unique id (UUID) of the user
  */
  userId?: string;
  /**
   * The settings the user has for the app
  */
  settings: EventSetting[];
}

/**
 * Alerting Email Settings of the user for a particular app
*/
export interface AlertUserAppEmailSettingsResult extends AlertUserEmailSettingsResult {
  /**
   * Application ID
  */
  appId?: string;
  /**
   * A flag indicating if settings are enabled at user/global level
  */
  userEnabled: boolean;
}

/**
 * Bugtracker specific settings
*/
export interface AlertingBugtrackerSettings {
  callbackUrl?: string;
  ownerName: string;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * VSTS bugtracker specific settings
*/
export interface AlertingVstsBugtrackerSettings extends AlertingBugtrackerSettings {
  vstsProjectId: string;
  vstsProjectUri: string;
  vstsProjectName?: string;
  vstsAccountName?: string;
  vstsAreaPath?: string;
  vstsDefaultPayload?: any;
}

/**
 * Github bugtracker specific settings
*/
export interface AlertingGithubBugtrackerSettings extends AlertingBugtrackerSettings {
  githubRepoId: number;
  githubRepoName: string;
  githubLabel?: string;
}

/**
 * Jira bugtracker specific settings
*/
export interface AlertingJiraBugtrackerSettings extends AlertingBugtrackerSettings {
  jiraProjectId: number;
  jiraProjectName: string;
}

/**
 * Alerting bugtracker resource
*/
export interface AlertingBugtracker {
  /**
   * type of bugtracker. Possible values include: 'github', 'vsts', 'jira'
  */
  type?: string;
  /**
   * bugtracker state. Possible values include: 'enabled', 'disabled', 'unauthorized'
  */
  state?: string;
  /**
   * ID of OAuth token
  */
  tokenId?: string;
  /**
   * Event types enabled for bugtracker
  */
  eventTypes?: string[];
  /**
   * Threshold for the number of crashes at which to create a bug
  */
  crashCountThreshold?: number;
  settings?: AlertingBugtrackerSettings;
}

/**
 * Contains the token ID for a bug tracker
*/
export interface BugTrackerTokenId {
  tokenId?: string;
}

/**
 * Repository owner object
*/
export interface AlertBugTrackerRepoOwner {
  name?: string;
  id?: string;
  login?: string;
}

/**
 * Repostiory object
*/
export interface AlertBugTrackerRepo {
  name: string;
  url: string;
  id: string;
  description?: string;
  privateProperty?: boolean;
  owner?: AlertBugTrackerRepoOwner;
}

/**
 * List of bug tracker repositories
*/
export interface AlertBugTrackerReposResult {
  /**
   * Possible values include: 'github', 'vsts', 'jira'
  */
  repoType?: string;
  repositories: AlertBugTrackerRepo[];
}

/**
 * AlertCrashGroup patching parameter
*/
export interface AlertCrashGroupStateChange {
  /**
   * Possible values include: 'Open', 'Closed', 'Ignored'
  */
  state?: string;
}

/**
 * Access token details
*/
export interface AlertingAccessTokenResponse {
  /**
   * ID of the access token
  */
  accessTokenId: string;
  /**
   * External provider name. Possible values include: 'github', 'vsts', 'jira'
  */
  externalProviderName: string;
  /**
   * The email of external user that used to authenticate aginst the external oauth provider
  */
  externalUserEmail: string;
  /**
   * The account name of external user that used to authenticate against the external oauth
   * provider or basic auth
  */
  externalAccountName: string;
}

/**
 * Alerting event
*/
export interface AlertingEvent {
  /**
   * ISO 8601 date time when event was generated
  */
  eventTimestamp: string;
  /**
   * A unique identifier for this event instance. Useful for deduplication
  */
  eventId: string;
  /**
   * Obsolete. Use emailProperties.
  */
  properties?: any;
}

/**
 * Properties of new crash group
*/
export interface NewCrashGroupAlertingEventCrashGroupProperties {
  id: string;
  name: string;
  reason: string;
  url: string;
  appDisplayName: string;
  appPlatform: string;
  appVersion: string;
  stackTrace: string[];
}

/**
 * New crash group alerting event
*/
export interface NewCrashGroupAlertingEvent extends AlertingEvent {
  /**
   * Properties of new crash group
  */
  crashGroupProperties?: NewCrashGroupAlertingEventCrashGroupProperties;
}

/**
 * Properties of new application release
*/
export interface NewAppReleaseAlertingEventAppReleaseProperties {
  appName: string;
  appDisplayName: string;
  releaseId: string;
  platform: string;
  /**
   * Date and time in ISO 8601 format
  */
  uploadedAt: string;
  fingerprint?: string;
  releaseNotes?: string;
  version: string;
  shortVersion: string;
  minOs?: string;
  mandatoryUpdate?: boolean;
  size: number;
  provisioningProfileName?: string;
  provisioningProfileType?: string;
  bundleIdentifier: string;
  installLink: string;
  iconLink?: string;
  distributionGroupId?: string;
  installable?: boolean;
}

/**
 * New app release alerting event
*/
export interface NewAppReleaseAlertingEvent extends AlertingEvent {
  /**
   * List of users who need to receive an email notification. If this is not null, then only
   * sending emails will be triggered even if the event requires calling webhooks or doing other
   * actions.
  */
  userIds?: string[];
  /**
   * indicate whether notify via webhook or not
  */
  disableWebhook?: boolean;
  /**
   * Properties of new application release
  */
  appReleaseProperties?: NewAppReleaseAlertingEventAppReleaseProperties;
}

/**
 * Object returned in response to getting a bug tracker issue related to a crash group id
*/
export interface BugTrackerIssueResult {
  id?: string;
  url?: string;
  title?: string;
  /**
   * Possible values include: 'github', 'vsts', 'jira'
  */
  bugTrackerType?: string;
  repoName?: string;
  mobileCenterId?: string;
  eventType?: string;
}

/**
 * Returns a list of all issues associated with a repo
*/
export interface BugTrackerIssuesResult {
  issues?: BugTrackerIssueResult[];
}

/**
 * Object returned in response to getting or updating the state of a bugtracker
*/
export interface BugTrackerStateResult {
  /**
   * bugtracker state. Possible values include: 'enabled', 'disabled', 'unauthorized'
  */
  state?: string;
}

/**
 * Object returned in response to accepting an event occurance
*/
export interface EventResponseResult extends AlertOperationResult {
}

/**
 * Alerting service error
*/
export interface AlertingError extends AlertOperationResult {
  /**
   * The status code return by the API. It can be 400 or 404 or 409 or 500.
  */
  code: number;
  /**
   * The reason for the request failed
  */
  message?: string;
}

/**
 * Billing Plan
*/
export interface BillingPlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  limits?: { [propertyName: string]: number };
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface BillingPlanSelection {
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  plan?: BillingPlan;
}

/**
 * Billing plans for a given period
*/
export interface BillingPeriod {
  /**
   * Inclusive start of the period
  */
  startTime?: string;
  /**
   * Exclusive end of the period.
  */
  endTime?: string;
  byAccount?: BillingPlanSelection;
}

/**
 * Billing Plans for a single service
*/
export interface ServiceBillingPlans {
  /**
   * Can customer select trial plan for that service (if it exists)?
  */
  canSelectTrialPlan?: boolean;
  /**
   * Expiration time of the last selected trial plan. Will be null if trial plan was not used.
  */
  lastTrialPlanExpirationTime?: string;
  currentBillingPeriod?: BillingPeriod;
}

/**
 * Billing Plans section in the Billing Information
*/
export interface BillingInformationPlans {
  buildService?: ServiceBillingPlans;
  testService?: ServiceBillingPlans;
}

/**
 * Usage for a single period
*/
export interface UsagePeriod {
  /**
   * Inclusive start time of the usage period
  */
  startTime?: string;
  /**
   * Exclusive end time of the usage period.
  */
  endTime?: string;
  byAccount?: { [propertyName: string]: number };
  byApp?: { [propertyName: string]: { [propertyName: string]: number } };
}

/**
 * Resource usage for a single Mobile Center service
*/
export interface ServiceResourceUsage {
  currentUsagePeriod?: UsagePeriod;
}

/**
 * Usage section in the Billing Information
*/
export interface BillingResourceUsage {
  buildService?: ServiceResourceUsage;
  testService?: ServiceResourceUsage;
}

/**
 * Aggregated Billing Information for a user or an organization
*/
export interface AggregatedBillingInformation {
  /**
   * Version of the Billing Information schema
  */
  version?: string;
  /**
   * The ISO 8601 datetime of last modification
  */
  timestamp?: string;
  /**
   * ID of the user or organization
  */
  id?: string;
  billingPlans?: BillingInformationPlans;
  usage?: BillingResourceUsage;
  /**
   * Unique identifier for the Azure subscription used for billing
  */
  azureSubscriptionId?: string;
  /**
   * State of the Azure subscription used for billing. Possible values include: 'Enabled',
   * 'Disabled', 'NotSet'
  */
  azureSubscriptionState?: string;
}

export interface BillingErrorError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed
  */
  message?: string;
}

/**
 * Error
*/
export interface BillingError {
  error?: BillingErrorError;
}

export interface BillingInformationSearchResultsItem {
  /**
   * The Account ID
  */
  accountId?: string;
  /**
   * The Account Name
  */
  accountName?: string;
  /**
   * The Billing Internal Account ID
  */
  billingInternalAccountId?: string;
  /**
   * The ID of the Build Billing Plan
  */
  buildPlan?: string;
  /**
   * The ID of the Test Billing Plan
  */
  testPlan?: string;
}

/**
 * Responses for requests that detect billing plans change type
*/
export interface BillingPlansChangeTypeResponse {
  /**
   * Possible values include: 'NoChange', 'Downgrade', 'Upgrade'
  */
  result?: string;
}

/**
 * Selection of a billing plan for one or more services
*/
export interface BillingPlansSelection {
  buildService?: BillingPlanSelection;
  testService?: BillingPlanSelection;
}

/**
 * GDPR tests verification result
*/
export interface GdprVerificationResult {
  /**
   * Verification status. True means that the verification was successfull.
  */
  status?: boolean;
  /**
   * Optional error message if the verification failed.
  */
  message?: string;
}

/**
 * GitHub account information
*/
export interface GitHubAccount {
  /**
   * Id of GitHub account
  */
  id?: number;
  /**
   * Type of GitHub account. Possible values include: 'User', 'Organization'
  */
  accountType?: string;
}

/**
 * GitHub Marketplace plan
*/
export interface GitHubMarketplacePlan {
  /**
   * Id of the GitHub plan
  */
  id?: number;
}

/**
 * GitHub Marketplace purchase
*/
export interface GitHubMarketplacePurchase {
  account?: GitHubAccount;
  plan?: GitHubMarketplacePlan;
}

/**
 * Status of the usage record creation
*/
export interface UsageRecordStatus {
  /**
   * Is the age of the most recent Build service usage record within expected limits
  */
  expectedLatestBuildExists?: boolean;
  /**
   * Is the age of the most recent Test service usage record within expected limits
  */
  expectedLatestTestExists?: boolean;
  /**
   * The time of the most recent Build service usage record
  */
  latestBuildUsageRecordTime?: string;
  /**
   * The time of the most recent Test service usage record
  */
  latestTestUsageRecordTime?: string;
}

/**
 * Billing Plan with a version
*/
export interface VersionedBillingPlan {
  document?: BillingPlan;
  /**
   * The version of the object
  */
  etag?: string;
}

/**
 * Envelope for messages sent to actors
*/
export interface MessageEnvelope {
  /**
   * Unique id of the message
  */
  messageId?: string;
  /**
   * Type of the message
  */
  messageType?: string;
  /**
   * Body of the message
  */
  message?: any;
}

export interface DataSubjectRightEmailRequest {
  /**
   * Email used for cancel delete with x-authz-bypass headers
  */
  email: string;
}

export interface DataSubjectRightResponse {
  /**
   * Unique request identifier
  */
  token: string;
  /**
   * ISO 8601 format timestamp of when request was created.
  */
  createdAt: Date;
}

export interface DataSubjectRightStatusResponse {
  /**
   * Azure Storage shared access signature (SAS) URL for exported user data.
  */
  sasUrl?: string;
  /**
   * Whether Azure Storage shared access signature (SAS) URL has expired or not.
  */
  sasUrlExpired?: boolean;
  /**
   * Status of data subject right request. Possible values include: 'None', 'Created', 'Queued',
   * 'InProgress', 'Completed', 'Failed'
  */
  status: string;
  /**
   * explanation message of the status
  */
  message: string;
}

/**
 * This response contains the Azure AD B2C client ID for an application.
*/
export interface ClientIdResponse {
  clientId?: string;
}

export interface AuthTenant {
  id: string;
  name: string;
}

export interface AuthTenantsResponse {
  value?: AuthTenant[];
}

export interface ApplicationResponse {
  id?: string;
  createdAt?: Date;
  name?: string;
}

export interface ApplicationsResponse {
  value?: ApplicationResponse[];
}

export interface ScopeResponse {
  id?: string;
  appName?: string;
  scope?: string;
  url?: string;
}

export interface ScopesResponse {
  value?: ScopeResponse[];
}

export interface AuthApplicationResponse {
  id: string;
  tenantId: string;
  tenantName: string;
  policyId: string;
  scopeId: string;
  scopeUrl: string;
  isSdkConfigured?: boolean;
}

export interface AuthApplicationPatchRequest {
  policyId: string;
  scopeId: string;
  scopeUrl: string;
}

export interface ExistingAuthApplicationPostRequest {
  tenantId: string;
  tenantName: string;
  id: string;
  policyId: string;
  scopeId: string;
  scopeUrl: string;
}

export interface TrustFrameworkPolicyResponse {
  id?: string;
}

export interface TrustFrameworkPoliciesResponse {
  value?: TrustFrameworkPolicyResponse[];
}

/**
 * This response contains the location of the resource URI for 201 or 202 responses.
*/
export interface LocationResponse {
  location?: string;
}

export interface InnerError {
  code?: string;
  innererror?: InnerError;
}

/**
 * This response contains an estimated price-per-RU denominated in a given currency.
*/
export interface EstimatedPricingResponse {
  pricePerHour?: number;
  /**
   * Possible values include: 'USD', 'EUR', 'GBP', 'AUD', 'INR', 'CAD', 'ARS', 'BRL', 'DKK', 'HKD',
   * 'IDR', 'JPY', 'KRW', 'MYR', 'MXN', 'NZD', 'NOK', 'RUB', 'SAR', 'ZAR', 'SEK', 'CHF', 'TWD',
   * 'TRY'
  */
  currency?: string;
}

export interface DataInstance {
  id: string;
  name: string;
}

export interface DataInstancesResponse {
  value?: DataInstance[];
}

export interface InstanceDatabase {
  id: string;
  name: string;
}

export interface InstanceDatabasesResponse {
  value?: InstanceDatabase[];
}

export interface DatabaseCollection {
  id: string;
  name: string;
}

export interface DatabaseCollectionsResponse {
  value?: DatabaseCollection[];
}

export interface UserResponse {
  accountId: string;
  mail?: string;
  displayName: string;
}

export interface UsersResponse {
  value: UserResponse[];
}

export interface DataProvisioningParameters {
  subscriptionId?: string;
  databaseConnectionString?: string;
  /**
   * Possible values include: 'East Asia', 'Southeast Asia', 'Australia Central', 'Australia
   * Central 2', 'Australia East', 'Australia Southeast', 'Brazil South', 'Canada Central', 'Canada
   * East', 'Central India', 'South India', 'West India', 'North Europe', 'West Europe', 'France
   * Central', 'France South', 'Germany Central', 'Germany Northeast', 'Japan East', 'Japan West',
   * 'Korea Central', 'Korea South', 'South Africa North', 'South Africa West', 'UK South', 'UK
   * West', 'Central US', 'East US', 'East US 2', 'US Gov Arizona', 'US Gov Texas', 'North Central
   * US', 'South Central US', 'West US', 'West US 2', 'West Central US'
  */
  resourceRegion?: string;
  database?: string;
  collection?: string;
  requestUnits?: number;
  accountName?: string;
}

export interface ProvisionStatusResponse {
  /**
   * Possible values include: 'Empty', 'Accepted', 'Creating', 'Connected', 'Invalid'
  */
  status: string;
  message?: string;
}

export interface ListOKResponseItem {
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
}

export interface DestinationTesterUpdateDetails {
  /**
   * Whether a release is mandatory for the given destination
  */
  mandatoryUpdate: boolean;
}

export interface DestinationGroupUpdateDetails {
  /**
   * Whether a release is mandatory for the given destination
  */
  mandatoryUpdate: boolean;
}
